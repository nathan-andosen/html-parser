{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/utility.ts","webpack:///./src/constants.ts","webpack:///./src/attribute-parser.ts","webpack:///./src/clean-parser.ts","webpack:///./src/index.ts","webpack:///./spec/in-browser/index.js","webpack:///./spec/unit sync .spec$","webpack:///./spec/unit/attribute-parser.spec.ts","webpack:///./spec/unit/clear-parser.spec.ts","webpack:///./src/html-parser.ts","webpack:///./spec/unit/html-parser.spec.ts","webpack:///./spec/unit/utility.spec.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","removeWhitespace","text","trim","split","join","isWhitespace","ch","textOnlyContainsWhitespace","isOnlyWhitespace","length","this","isLetter","isStartOfTag","nextCh","isEndOfTag","isStartOfComment","indexOf","Utility","utility","ELEMENT_TYPES","TAG","TEXT","COMMENT","EMPTY_TAGS","MODE_TYPES","STYLE","SCRIPT","TAG_TYPES","EMPTY","DEFAULT","QUOTE_TYPES","SINGLE","DOUBLE","PARSER_MODES","state","currentPos","attrName","attrValue","reset","getNextChar","charAt","_parse","attr","handleReadingAttrName","handleReadingAttrValue","firstCh","lastCh","parse","tag","posOfFirstSpace","posOfGreaterThan","lastIndexOf","substring","reverse","attributes","textAttr","AttributeParser","setOptions","options","removeEmptyTags","removeEmptyTextNodes","parseAndRemoveEmptyText","index","nodes","node","type","data","splice","children","parseAndRemoveEmptyTags","noChildern","tagType","htmlNodes","CleanParser","HtmlParser","testsContext","keys","forEach","map","webpackContext","req","id","webpackContextResolve","e","Error","code","resolve","describe","attrParser","it","output","expect","JSON","stringify","toEqual","htmlParser","cleanParser","errorCb","addNodeCb","stringifyNodeCb","html","addNodeElement","newNode","currentElement","push","createTextNode","createCommentNode","comment","createTagNode","endIndex","getTagType","parseAttributes","toLowerCase","getNextTag","pos","substr","parseText","nextText","tagResult","handleStartTagInText","handleEndTagInText","handleCommentInText","textNode","posEndTag","tagName","replace","err","parentElement","posEndCommentTag","commentText","commentNode","parseTag","findPositionOfClosingTag","tagText","tagNode","quoteType","insideQuote","parseScript","endTag","posOfEndTag","scriptContent","reverseNodes","clean","errorCalled","toBeGreaterThan","cnt","parentNode","reversedHtml","newHtml"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,SAIjBlC,EAAoBA,EAAoBmC,EAAI,G,gFC5ErD,+BAmHA,OA1GS,YAAAC,iBAAP,SAAwBC,GActB,OADAA,GADAA,GADAA,GADAA,GADAA,GADAA,GADAA,EAAOA,EAAKC,QACAC,MAAM,KAAKC,KAAK,KAChBD,MARF,MAQaC,KAAK,KAChBD,MARO,KAQaC,KAAK,KACzBD,MARE,MAQaC,KAAK,KACpBD,MARH,MAQaC,KAAK,KACfD,MARH,MAQaC,KAAK,KAYtB,YAAAC,aAAP,SAAoBC,GAMlB,MALU,OAKFA,GAAuB,MAAPA,GAJL,MAIqBA,GAH1B,OAIRA,GAHG,OAGiBA,GAFjB,OAEgCA,GAWpC,YAAAC,2BAAP,SAAkCN,GAChC,IAAIO,GAAmB,EACvB,IAAIP,EAAQ,OAAOO,EACnB,IAAI,IAAIxC,EAAI,EAAGA,EAAIiC,EAAKQ,OAAQzC,IAC9B,IAAI0C,KAAKL,aAAaJ,EAAKjC,IAAK,CAC9BwC,GAAmB,EACnB,MAGJ,OAAOA,GAWF,YAAAG,SAAP,SAAgBL,GACd,OAAQA,GAAM,KAAOA,GAAM,KAASA,GAAM,KAAOA,GAAM,KAYlD,YAAAM,aAAP,SAAoBN,EAAYO,GAC9B,SAAIP,IAAOO,KACI,MAAPP,GAAcI,KAAKC,SAASE,KAY/B,YAAAC,WAAP,SAAkBR,EAAYO,GAC5B,SAAIP,IAAOO,KACI,MAAPP,GAAyB,MAAXO,IAWjB,YAAAE,iBAAP,SAAwBd,GACtB,OAAiC,IAAzBA,EAAKe,QAAQ,YAEzB,EAnHA,GAAa,EAAAC,UAsHb,IAAIC,EAAU,IAAID,EACT,EAAAC,W,8EC7HI,EAAAC,cAAgB,CAC3BC,IAAK,MACLC,KAAM,OACNC,QAAS,WAGE,EAAAC,WAAa,CACxB,KAAQ,EACR,KAAQ,EACR,SAAY,EACZ,GAAM,EACN,IAAO,EACP,MAAS,EACT,GAAM,EACN,IAAO,EACP,MAAS,EACT,QAAW,EACX,KAAQ,EACR,KAAQ,EACR,MAAS,EACT,MAAS,GAGE,EAAAC,WAAa,CACxBH,KAAM,OACND,IAAK,MACLK,MAAO,QACPC,OAAQ,UAGG,EAAAC,UAAY,CACvBC,MAAO,QACPC,QAAS,UACTH,OAAQ,SACRD,MAAO,QACPH,QAAS,WAGE,EAAAQ,YAAc,CACzBC,OAAQ,EACRC,OAAQ,I,8ECxCV,WAEMC,EACe,oBADfA,EAEgB,qBAStB,0BAGU,KAAAC,MAAa,CACnBjC,KAAM,GACNkC,WAAY,EACZhD,KAAM8C,EACNG,SAAU,GACVC,UAAW,IAmKf,OAzJU,YAAAC,MAAR,WACE5B,KAAKwB,MAAQ,CACXjC,KAAM,GACNkC,WAAY,EACZhD,KAAM,oBACNiD,SAAU,GACVC,UAAW,KAYP,YAAAE,YAAR,WACE,IAAIjC,EAAK,KAKT,OAJGI,KAAKwB,MAAMC,WAAazB,KAAKwB,MAAMjC,KAAKQ,SACzCH,EAAKI,KAAKwB,MAAMjC,KAAKuC,OAAO9B,KAAKwB,MAAMC,YACvCzB,KAAKwB,MAAMC,cAEN7B,GAYD,YAAAmC,OAAR,SAAexC,GACb,IAAIyC,EAAO,GAEX,IADAhC,KAAKwB,MAAMjC,KAAOA,IACN,CACV,IAAIK,EAAKI,KAAK6B,cACd,GAAU,OAAPjC,EAAa,CACXI,KAAKwB,MAAME,WACZM,EAAKhC,KAAKwB,MAAME,UAAa1B,KAAKwB,MAAe,UAC7CxB,KAAKwB,MAAMG,UAAY,MAE7B,MAEC3B,KAAKwB,MAAM/C,OAAS8C,EACrBvB,KAAKiC,sBAAsBrC,EAAIoC,GACvBhC,KAAKwB,MAAM/C,OAAS8C,GAC5BvB,KAAKkC,uBAAuBtC,EAAIoC,GAGpC,OAAOA,GAYD,YAAAC,sBAAR,SAA8BrC,EAAYoC,GAC9B,MAAPpC,EAEDI,KAAKwB,MAAM/C,KAAO8C,EACH,MAAP3B,IAGA,EAAAY,QAAQb,aAAaC,GAE1BI,KAAKwB,MAAME,WACZM,EAAKhC,KAAKwB,MAAME,UAAY,KAC5B1B,KAAKwB,MAAME,SAAW,IAGxB1B,KAAKwB,MAAME,SAAW1B,KAAKwB,MAAME,SAAW9B,IAaxC,YAAAsC,uBAAR,SAA+BtC,EAAYoC,GACzC,GAAG,EAAAxB,QAAQb,aAAaC,GAAK,CAC3B,IAAIuC,EAAUnC,KAAKwB,MAAMG,UAAU,GAC/BS,EAASpC,KAAKwB,MAAMG,UAAU3B,KAAKwB,MAAMG,UAAU5B,OAAS,GAChD,MAAZoC,GAA+B,MAAZA,GAAoBA,IAAYC,GAKrDJ,EAAKhC,KAAKwB,MAAME,UAAY1B,KAAKwB,MAAMG,UACvC3B,KAAKwB,MAAM/C,KAAO8C,EAClBvB,KAAKwB,MAAME,SAAW,GACtB1B,KAAKwB,MAAMG,UAAY,IALvB3B,KAAKwB,MAAMG,UAAY3B,KAAKwB,MAAMG,UAAY/B,OAQhDI,KAAKwB,MAAMG,UAAY3B,KAAKwB,MAAMG,UAAY/B,GAY3C,YAAAyC,MAAP,SAAaC,GACXtC,KAAK4B,QACL,IAAII,EAAO,GACPO,EAAkBD,EAAIhC,QAAQ,KAC9BkC,EAAmBF,EAAIG,YAAY,KACvC,GAAGF,GAAmB,GAAKA,EAAkBC,EAAkB,CAE7D,IAAIjD,EAAO+C,EAAII,UAAUH,EAAiBC,GAC1CjD,EAAOA,EAAKC,OACZwC,EAAOhC,KAAK+B,OAAOxC,GAErB,OAAOyC,GAWF,YAAAW,QAAP,SAAeC,GACb,IAAIC,EAAW,GACf,IAAI,IAAIhE,KAAO+D,EACU,OAApBA,EAAW/D,GACZgE,GAAY,IAAMhE,EAElBgE,GAAY,IAAMhE,EAAM,IAAM+D,EAAW/D,GAG7C,OAAOgE,EAASrD,QAEpB,EA3KA,GAAa,EAAAsD,mB,8ECZb,WACA,OASA,2BA8FA,OAlFU,YAAAC,WAAR,SAAmBC,GACjBA,EAAUA,GAAW,GACrBhD,KAAKiD,qBAAsD,IAA5BD,EAAQC,iBACnCD,EAAQC,gBACZjD,KAAKkD,0BACsC,IAAjCF,EAAQE,sBACdF,EAAQE,sBAaN,YAAAC,wBAAR,SAAgCC,EAAeC,GAC7C,KAAGD,GAASC,EAAMtD,QAAlB,CAGA,IAAIuD,EAAOD,EAAMD,GACdE,EAAKC,OAAS,EAAA9C,cAAcE,MAC5B,EAAAH,QAAQX,2BAA2ByD,EAAKE,OACzCH,EAAMI,OAAOL,EAAO,GACpBA,KACQE,EAAKC,OAAS,EAAA9C,cAAcC,KAAO4C,EAAKI,UAC/CJ,EAAKI,SAAS3D,OAAS,GACxBC,KAAKmD,wBAAwB,EAAGG,EAAKI,UAEvC1D,KAAKmD,0BAA0BC,EAAOC,KAahC,YAAAM,wBAAR,SAAgCP,EAAeC,GAC7C,KAAGD,GAASC,EAAMtD,QAAlB,CAGA,IAAIuD,EAAOD,EAAMD,GACjB,GAAGE,EAAKC,OAAS,EAAA9C,cAAcC,IAAK,CAC/B4C,EAAKI,UAAYJ,EAAKI,SAAS3D,OAAS,GACzCC,KAAK2D,wBAAwB,EAAGL,EAAKI,UAEvC,IAAIE,GAAeN,EAAKI,UAAYJ,EAAKI,SAAS3D,QAAU,EACzDuD,EAAKO,UAAY,EAAA5C,UAAUE,SAAWyC,IACvCP,EAAMI,OAAOL,EAAO,GACpBA,KAGJpD,KAAK2D,0BAA0BP,EAAOC,KAYxC,YAAAhB,MAAA,SAAMyB,EAA2Bd,GAQ/B,OAPAhD,KAAK+C,WAAWC,GACbhD,KAAKkD,sBACNlD,KAAKmD,wBAAwB,EAAGW,GAE/B9D,KAAKiD,iBACNjD,KAAK2D,wBAAwB,EAAGG,GAE3BA,GAEX,EA9FA,GAAa,EAAAC,e,8ECXb,WAAS,EAAAtD,cAAA,EAAAA,cAAe,EAAAQ,UAAA,EAAAA,UAExB,WAAS,EAAA+C,WAAA,EAAAA,Y,gBCGT,IAAIC,EAAe,KACnBA,EAAaC,OAAOC,QAAQF,I,gBCN5B,IAAIG,EAAM,CACT,0BAA2B,EAC3B,sBAAuB,EACvB,qBAAsB,GACtB,iBAAkB,IAInB,SAASC,EAAeC,GACvB,IAAIC,EAAKC,EAAsBF,GAC/B,OAAOpH,EAAoBqH,GAE5B,SAASC,EAAsBF,GAC9B,IAAIpH,EAAoBa,EAAEqG,EAAKE,GAAM,CACpC,IAAIG,EAAI,IAAIC,MAAM,uBAAyBJ,EAAM,KAEjD,MADAG,EAAEE,KAAO,mBACHF,EAEP,OAAOL,EAAIE,GAEZD,EAAeH,KAAO,WACrB,OAAOlG,OAAOkG,KAAKE,IAEpBC,EAAeO,QAAUJ,EACzBnH,EAAOD,QAAUiH,EACjBA,EAAeE,GAAK,G,8ECzBpB,WAKAM,SAAS,oBAAoB,WAC3B,IAAIC,EAAa,IAAI,EAAAhC,gBAKrB+B,SAAS,WAAW,WAClBE,GAAG,8CAA8C,WAC/C,IAEIC,EAASF,EAAWzC,MAFd,6DAGV4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,MAAQ,cAAgB,cAAc,YAAc,IAAM,kBAKlFJ,GAAG,kCAAkC,WACnC,IAEIC,EAASF,EAAWzC,MAFd,yCAGV4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,MAAQ,QAAQ,WAAW,kBAKnDJ,GAAG,uCAAuC,WACxC,IAEIC,EAASF,EAAWzC,MAFd,8BAGV4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,KAAO,OAAO,KAAO,cAK7CJ,GAAG,8CAA8C,WAC/C,IAEIC,EAASF,EAAWzC,MAFd,gCAGV4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,SAAW,KAAK,IAAM,cAK9CJ,GAAG,+BAA+B,WAChC,IAAIzC,EAAM,QACN0C,EAASF,EAAWzC,MAAMC,GAC9B2C,OAAOC,KAAKC,UAAUH,IAASI,QAAQ,MACvC9C,EAAM,QACN0C,EAASF,EAAWzC,MAAMC,GAC1B2C,OAAOC,KAAKC,UAAUH,IAASI,QAAQ,MACvC9C,EAAM,SACN0C,EAASF,EAAWzC,MAAMC,GAC1B2C,OAAOC,KAAKC,UAAUH,IAASI,QAAQ,SAGzCL,GAAG,mCAAmC,WACpC,IAGIC,GAHa,IAAI,EAAAlC,iBAGGT,MAFd,gHAGV4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,MAAQ,WAAW,aAAa,iBAAmB,OAAS,aAAa,IAAM,KAAK,SAAW,KAAK,eAAe,OAAO,QAAQ,YAK1JJ,GAAG,gDAAgD,WACjD,IAIIC,EAASF,EAAWzC,MAJd,wEAKV4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,MAAQ,OAAS,OAAS,QAAQ,SAAW,KAAK,KAAO,aAKjFJ,GAAG,sEAAsE,WACvE,IACIC,EAASF,EAAWzC,MADd,kCAGV4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UADvB,CAAC,IAAM,QAAQ,OAAS,iBAUjDN,SAAS,aAAa,WACpBE,GAAG,iEAAiE,WAClE,IAEIC,EAASF,EAAWzC,MAFd,8CAGNQ,EAAWiC,EAAWnC,QAAQqC,GAClCC,OAAOpC,GAAUuC,QAHI,oD,8ECrF3B,WACA,OAMAP,SAAS,eAAe,WACtB,IAAIQ,EAAa,IAAI,EAAArB,WACjBsB,EAAc,IAAI,EAAAvB,YAMtBc,SAAS,WAAW,WAClBE,GAAG,oCAAoC,WACrC,IACIC,EAASK,EAAWhD,MADb,0CAEX2C,EAASM,EAAYjD,MAAM2C,EAAQ,CACjC9B,sBAAsB,IAGxB+B,OAAOI,EAAW1C,QAAQqC,IAASI,QADd,qBAIvBL,GAAG,4BAA4B,WAC7B,IACIC,EAASK,EAAWhD,MADb,gEAEX2C,EAASM,EAAYjD,MAAM2C,EAAQ,CACjC9B,sBAAsB,IAGxB+B,OAAOI,EAAW1C,QAAQqC,IAASI,QADd,+CAIvBL,GAAG,kCAAkC,WACnC,IACIC,EAASK,EAAWhD,MADb,6CAEX2C,EAASM,EAAYjD,MAAM2C,EAAQ,CACjC/B,iBAAiB,IAGnBgC,OAAOI,EAAW1C,QAAQqC,IAASI,QADd,qD,8EC1C3B,WACA,OAaA,OACA,OASA,0BAIU,KAAAG,QAAgC,KAChC,KAAAC,UACiC,KACjC,KAAAC,gBAAgD,KAyf1D,OAhfU,YAAA7D,MAAR,WACE5B,KAAKwB,MAAQ,CACX/C,KAAM,EAAAqC,WAAWH,KACjB+E,KAAM,GACNjE,WAAY,EACZuD,OAAQ,KAaJ,YAAAW,eAAR,SAAuBC,EAAuBC,GACzC7F,KAAKwF,WACNxF,KAAKwF,UAAUI,EAASC,GAEvBA,GACGA,EAAenC,WAAYmC,EAAenC,SAAW,IACzDmC,EAAenC,SAASoC,KAAKF,IAE7B5F,KAAKwB,MAAMwD,OAAOc,KAAKF,IAanB,YAAAG,eAAR,SAAuBxG,GACrB,MAAO,CACLgE,KAAM,EAAA9C,cAAcE,KACpB6C,KAAMjE,IAaF,YAAAyG,kBAAR,SAA0BC,GACxB,MAAO,CACL1C,KAAM,EAAA9C,cAAcG,QACpB4C,KAAMyC,IAaF,YAAAC,cAAR,SAAsB5D,GACpB,IAAIC,EAAkBD,EAAIhC,QAAQ,KAC9BkC,EAAmBF,EAAIhC,QAAQ,KAC/B6F,EAAY5D,GAAmB,GAAKA,EAAkBC,EACtDD,EAAkBC,EAClB3E,EAAOyE,EAAII,UAAU,EAAGyD,GAE5B,OADAtI,EAAO,EAAA2C,QAAQlB,iBAAiBzB,GACzB,CACL0F,KAAM,EAAA9C,cAAcC,IACpBmD,QAAS7D,KAAKoG,WAAWvI,GACzBA,KAAMA,EACN+E,WAAY5C,KAAKqG,gBAAgB/D,GACjCoB,SAAU,KAaN,YAAA0C,WAAR,SAAmBvI,GAEjB,OADAA,EAAOA,EAAKyI,cACT,EAAAzF,WAAWhD,GACL,EAAAoD,UAAUC,MACTrD,IAAS,EAAAoD,UAAUF,MACpB,EAAAE,UAAUF,MACTlD,IAAS,EAAAoD,UAAUD,OACpB,EAAAC,UAAUD,OACTnD,IAAS,EAAAoD,UAAUL,QACpB,EAAAK,UAAUL,QAEZ,EAAAK,UAAUE,SAYX,YAAAoF,WAAR,SAAmBhH,GAEjB,IADA,IAAIiH,EAAM,EACJA,EAAMjH,EAAKQ,QAAQ,CACvB,GAAG,EAAAS,QAAQN,aAAaX,EAAKiH,GAAMjH,EAAKiH,EAAM,IAC5C,MAAO,CACLjD,KAAM,QACNiD,IAAKA,GAEF,GAAG,EAAAhG,QAAQJ,WAAWb,EAAKiH,GAAMjH,EAAKiH,EAAM,IACjD,MAAO,CACLjD,KAAM,MACNiD,IAAKA,GAEF,GAAG,EAAAhG,QAAQH,iBAAiBd,EAAKkH,OAAOD,IAC7C,MAAO,CACLjD,KAAM,UACNiD,IAAKA,GAGTA,IAEF,MAAO,CAAEjD,KAAM,WAWT,YAAAmD,UAAR,SAAkBb,GAChB,IAAIc,EAAW3G,KAAKwB,MAAMkE,KAAKhD,UAAU1C,KAAKwB,MAAMC,YAChDmF,EAAY5G,KAAKuG,WAAWI,GAChC,GAAsB,UAAnBC,EAAUrD,KACXvD,KAAK6G,qBAAqBD,EAAWD,EAAUd,QAC1C,GAAsB,QAAnBe,EAAUrD,KAClBvD,KAAK8G,mBAAmBF,EAAWD,EAAUd,QACxC,GAAsB,YAAnBe,EAAUrD,KAClBvD,KAAK+G,oBAAoBH,EAAWD,EAAUd,QAG9C,GAAGc,EAAS5G,OAAS,EAAG,CACtB,IAAIiH,EAAWhH,KAAK+F,eAAeY,GACnC3G,KAAK2F,eAAeqB,EAAUnB,KAe5B,YAAAgB,qBAAR,SAA6BD,EAC7BD,EAAkBd,GAChB,GAAGe,EAAUJ,IAAM,EAAG,CAEpB,IAAIjH,EAAOoH,EAASjE,UAAU,EAAGkE,EAAUJ,KACvCQ,EAAWhH,KAAK+F,eAAexG,GACnCS,KAAK2F,eAAeqB,EAAUnB,GAGhC7F,KAAKwB,MAAM/C,KAAO,EAAAqC,WAAWJ,IAC7BV,KAAKwB,MAAMC,WAAazB,KAAKwB,MAAMC,WAAamF,EAAUJ,IAC1DxG,KAAK+B,OAAO8D,IAaN,YAAAiB,mBAAR,SAA2BF,EAC3BD,EAAkBd,GAChB,GAAGe,EAAUJ,IAAM,EAAG,CAEpB,IAAIjH,EAAOoH,EAASjE,UAAU,EAAGkE,EAAUJ,KACvCQ,EAAWhH,KAAK+F,eAAexG,GACnCS,KAAK2F,eAAeqB,EAAUnB,GAGhC,IAAIoB,EAAYN,EAASrG,QAAQ,IAAKsG,EAAUJ,KAAO,EAEnDU,EADUP,EAASjE,UAAUkE,EAAUJ,IAAKS,GAC1BE,QAAQ,KAAM,IAAIA,QAAQ,IAAK,IACrD,IAAItB,EAAgB,CAClB,IAAIuB,EAAM,IAAI1C,MAAM,6BAA+BwC,GAChDlH,KAAKuF,SAAWvF,KAAKuF,QAAQ6B,GAElC,GAAGvB,EAAehI,KAAKyI,gBAAkBY,EAAQZ,cAAe,CAC1Dc,EAAM1C,MAAM,cAAgBmB,EAAehI,KAA/B,kBACRqJ,EAAU,kBACflH,KAAKuF,SAAWvF,KAAKuF,QAAQ6B,GAElCpH,KAAKwB,MAAM/C,KAAO,EAAAqC,WAAWH,KAC7BX,KAAKwB,MAAMC,WAAazB,KAAKwB,MAAMC,WAAawF,EAChD,IAAII,EAAgBxB,EAAewB,qBAC5BxB,EAAewB,cACtBrH,KAAK+B,OAAOsF,IAaN,YAAAN,oBAAR,SAA4BH,EAC5BD,EAAkBd,GAChB,GAAGe,EAAUJ,IAAM,EAAG,CAEpB,IAAIjH,EAAOoH,EAASjE,UAAU,EAAGkE,EAAUJ,KACvCQ,EAAWhH,KAAK+F,eAAexG,GACnCS,KAAK2F,eAAeqB,EAAUnB,GAEhC,IAAIyB,EAAmBX,EAASrG,QAAQ,UACxC,IAAIgH,EAAkB,CACpB,IAAIF,EAAM,IAAI1C,MAAM,oCACjB1E,KAAKuF,SAAWvF,KAAKuF,QAAQ6B,GAElC,IAAIG,EAAcZ,EAASjE,UAAUkE,EAAUJ,IAAM,EAAGc,GACpDE,EAAcxH,KAAKgG,kBAAkBuB,GACzCvH,KAAK2F,eAAe6B,EAAa3B,GACjC7F,KAAKwB,MAAM/C,KAAO,EAAAqC,WAAWH,KAC7BX,KAAKwB,MAAMC,WAAazB,KAAKwB,MAAMC,YAAc6F,EAAmB,GACpEtH,KAAK+B,OAAO8D,IAWN,YAAA4B,SAAR,SAAiB5B,GACf,IAAIc,EAAW3G,KAAKwB,MAAMkE,KAAKhD,UAAU1C,KAAKwB,MAAMC,YAChDwF,EAAYjH,KAAK0H,yBAAyBf,GAAY,EACtDgB,EAAUhB,EAASjE,UAAU,EAAGuE,GAChCW,EAAU5H,KAAKkG,cAAcyB,GAEjC3H,KAAKwB,MAAMC,WAAazB,KAAKwB,MAAMC,WAAawF,EAChDjH,KAAK2F,eAAeiC,EAAS/B,GAC7B7F,KAAKwB,MAAM/C,KAAO,EAAAqC,WAAWH,KAC1BiH,EAAQ/D,UAAY,EAAA5C,UAAUC,MAE/BlB,KAAK+B,OAAO8D,GACJ+B,EAAQ/D,UAAY,EAAA5C,UAAUF,OACtCf,KAAKwB,MAAM/C,KAAO,EAAAqC,WAAWC,MAC7B6G,EAAQP,cAAgBxB,EACxB7F,KAAK+B,OAAO6F,IACJA,EAAQ/D,UAAY,EAAA5C,UAAUD,QACtChB,KAAKwB,MAAM/C,KAAO,EAAAqC,WAAWE,OAC7B4G,EAAQP,cAAgBxB,EACxB7F,KAAK+B,OAAO6F,KAEZA,EAAQP,cAAgBxB,EACxB7F,KAAK+B,OAAO6F,KAaR,YAAAF,yBAAR,SAAiCnI,GAC/B,IAAIgD,EAAkBhD,EAAKe,QAAQ,KAC/BkG,EAAOjE,GAAmB,EAAKA,EAAkB,EAAI,EACrDC,EAAmBjD,EAAKe,QAAQ,KACpC,GAAGkC,EAAmBgE,EACpB,OAAOhE,EAIT,IAFA,IAAIqF,EAAY,KACZC,GAAc,IACN,CACV,IAAIlI,EAAM4G,EAAMjH,EAAKQ,OAAUR,EAAKiH,GAAO,KAC3C,GAAU,MAAP5G,IAAekI,EAChB,OAAOtB,EACF,GAAU,MAAP5G,EACLkI,GAAeD,IAAc,EAAAzG,YAAYC,OAC1CyG,GAAc,EACLA,IACTA,GAAc,EACdD,EAAY,EAAAzG,YAAYC,aAErB,GAAU,MAAPzB,EACLkI,GAAeD,IAAc,EAAAzG,YAAYE,OAC1CwG,GAAc,EACLA,IACTA,GAAc,EACdD,EAAY,EAAAzG,YAAYE,aAErB,GAAU,OAAP1B,EAER,MAEF4G,IAEF,OAAOjH,EAAKQ,OAAS,GAYf,YAAAsG,gBAAR,SAAwB/D,GAEtB,OADiB,IAAI,EAAAQ,iBACHT,MAAMC,IAYlB,YAAAyF,YAAR,SAAoBlC,EAA8BmC,GAChD,IAAIrB,EAAW3G,KAAKwB,MAAMkE,KAAKhD,UAAU1C,KAAKwB,MAAMC,YAChDwG,EAActB,EAASrG,QAAQ0H,GACnC,GAAGC,EAAc,EAAG,CAClB,IAAIb,EAAM,IAAI1C,MAAM,WAAamB,EAAehI,KAA5B,+BAEjBmC,KAAKuF,SAAWvF,KAAKuF,QAAQ6B,GAElC,IAAIc,EAAgBvB,EAASjE,UAAU,EAAGuF,GACtCjB,EAAWhH,KAAK+F,eAAemC,GACnClI,KAAK2F,eAAeqB,EAAUnB,GAC9B7F,KAAKwB,MAAMC,WAAazB,KAAKwB,MAAMC,YAC9BwG,EAAcD,EAAOjI,QAC1BC,KAAKwB,MAAM/C,KAAO,EAAAqC,WAAWH,KAC7B,IAAI0G,EAAgBxB,EAAewB,qBAC5BxB,EAAewB,cACtBrH,KAAK+B,OAAOsF,IAWN,YAAAtF,OAAR,SAAe8D,GACb,OAAO7F,KAAKwB,MAAM/C,MAChB,KAAK,EAAAqC,WAAWH,KACdX,KAAK0G,UAAUb,GACf,MACF,KAAK,EAAA/E,WAAWJ,IACdV,KAAKyH,SAAS5B,GACd,MACF,KAAK,EAAA/E,WAAWC,MACdf,KAAK+H,YAAYlC,EAAgB,YACjC,MACF,KAAK,EAAA/E,WAAWE,OACdhB,KAAK+H,YAAYlC,EAAgB,gBAchC,YAAAxD,MAAP,SAAaqD,EAAcH,EAC3BC,GAOE,OALAxF,KAAKuF,QAAU,GAAsB,KACrCvF,KAAKwF,UAAY,GAA0B,KAC3CxF,KAAK4B,QACL5B,KAAKwB,MAAMkE,KAAOA,EAClB1F,KAAK+B,OAAO,MACL/B,KAAKwB,MAAMwD,QAWb,YAAArC,QAAP,SAAemB,EACf2B,GAEE,OADAzF,KAAKyF,gBAAkB,GAAsC,KACtDzF,KAAKmI,aAAa,EAAGrE,EAAW,KAcjC,YAAAqE,aAAR,SAAqB/E,EAAeU,EAA2B4B,GAC7D,GAAGtC,GAASU,EAAU/D,OACpB,OAAO2F,EAET,IAAIpC,EAAOQ,EAAUV,GAErB,GADGpD,KAAKyF,iBAAmBzF,KAAKyF,gBAAgBnC,GAC7CA,EAAKC,OAAS,EAAA9C,cAAcE,KAC7B+E,GAAQpC,EAAKE,UACR,GAAGF,EAAKC,OAAS,EAAA9C,cAAcG,QACpC8E,GAAQ,UAASpC,EAAKE,KAAO,aACxB,CACL,IACIX,GADa,IAAI,EAAAC,iBACKH,QAAQW,EAAKV,YAGvC,GAFAC,EAAYA,EAAS9C,OAAS,EAAK,IAAM8C,EAAWA,EAEjDS,EAAKO,UAAY,EAAA5C,UAAUC,MAC5BwE,GAAQ,IAAMpC,EAAKzF,KAAOgF,EAAW,UAChC,CAEL,GADA6C,GAAQ,IAAMpC,EAAKzF,KAAOgF,EAAW,IAClCS,EAAKI,UAAYJ,EAAKI,SAAS3D,OAAS,EAEzC2F,GADc1F,KAAKmI,aAAa,EAAG7E,EAAKI,SAAU,IAGpDgC,GAAQ,KAAOpC,EAAKzF,KAAO,KAI/B,OADAuF,IACOpD,KAAKmI,aAAa/E,EAAOU,EAAW4B,IAYtC,YAAA0C,MAAP,SAAa/E,EAAuBL,GAElC,OADkB,IAAI,EAAAe,aACH1B,MAAMgB,EAAOL,IAEpC,EAhgBA,GAAa,EAAAgB,c,8ECxBb,WASAa,SAAS,cAAc,WACrB,IAAIQ,EAAa,IAAI,EAAArB,WAKrBa,SAAS,WAAW,WAElBE,GAAG,2BAA2B,WAC5B,IAEIC,EAASK,EAAWhD,MAFb,eAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,CAAC,KAAO,OAAO,KAAO,qBAM9CJ,GAAG,oCAAoC,WACrC,IAEIC,EAASK,EAAWhD,MAFb,qBAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,CAAC,KAAO,OAAO,KAAO,eAAe,CAAC,KAAO,MAAM,QAAU,QAAQ,KAAO,KAAK,WAAa,GAAG,SAAW,UAMpIJ,GAAG,8BAA8B,WAC/B,IAEIC,EAASK,EAAWhD,MAFb,wDAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,MAAM,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,UAAU,KAAO,oBAAoB,CAAC,KAAO,OAAO,KAAO,wBAMtKJ,GAAG,2BAA2B,WAC5B,IACIC,EAASK,EAAWhD,MADb,mFAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UADvB,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,OAAO,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,MAAM,QAAU,SAAS,KAAO,SAAS,WAAa,CAAC,KAAO,qBAAuB,SAAW,CAAC,CAAC,KAAO,OAAO,KAAO,uCAKnOJ,GAAG,0BAA0B,WAC3B,IACIC,EAASK,EAAWhD,MADb,2CAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UADvB,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,OAAO,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,MAAM,QAAU,QAAQ,KAAO,QAAQ,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,OAAO,KAAO,yBAKrMJ,GAAG,4BAA4B,WAC7B,IACIC,EAASK,EAAWhD,MADb,uDAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UADvB,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,MAAM,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,MAAM,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,IAAI,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,OAAO,KAAO,OAAO,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,OAAO,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,OAAO,KAAO,wBAKtXJ,GAAG,qCAAqC,WACtC,IACIC,EAASK,EAAWhD,MADb,6CAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UADvB,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,MAAM,WAAa,CAAC,MAAQ,SAAS,SAAW,CAAC,CAAC,KAAO,MAAM,QAAU,QAAQ,KAAO,QAAQ,WAAa,CAAC,SAAW,MAAM,SAAW,YAK3MJ,GAAG,sCAAsC,WACvC,IACIsD,EAAc,EACLhD,EAAWhD,MAFb,oBAEyB,SAAC+E,GACnCiB,OAEFpD,OAAOoD,GAAaC,gBAAgB,MAItCvD,GAAG,0CAA0C,WAC3C,IAEIC,EAASK,EAAWhD,MAFb,gCAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,OAAO,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,IAAI,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,OAAO,KAAO,QAAQ,CAAC,KAAO,OAAO,KAAO,kBAMjOJ,GAAG,4BAA4B,WAC7B,IACIC,EAASK,EAAWhD,MADb,8BAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UADvB,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,WAAW,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,OAAO,KAAO,iBAK9HJ,GAAG,wEAAwE,WACzE,IAEIC,EAASK,EAAWhD,MAFb,4BAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,IAAI,WAAa,GAAG,SAAW,CAAC,CAAC,KAAO,OAAO,KAAO,6BAMvHJ,GAAG,kDAAkD,WACnD,IACIC,EAASK,EAAWhD,MADb,2DAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UADvB,CAAC,CAAC,KAAO,MAAM,QAAU,QAAQ,KAAO,MAAM,WAAa,CAAC,IAAM,QAAQ,OAAS,SAAS,SAAW,IAAI,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,OAAO,WAAa,CAAC,MAAQ,KAAK,SAAW,CAAC,CAAC,KAAO,OAAO,KAAO,gBAK/OJ,GAAG,sCAAsC,WACvC,IACIC,EAASK,EAAWhD,MADb,uEAGX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UADvB,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,IAAI,WAAa,CAAC,OAAS,wBAAwB,SAAW,CAAC,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,OAAO,WAAa,CAAC,IAAM,kBAAkB,SAAW,YAKjOJ,GAAG,qCAAqC,WACtC,IAMIC,EAASK,EAAWhD,MANb,+CAOX4C,OAAOC,KAAKC,UAAUH,IAASI,QAAQF,KAAKC,UAFvB,CAAC,CAAC,KAAO,OAAO,KAAO,QAAQ,CAAC,KAAO,MAAM,QAAU,UAAU,KAAO,IAAI,WAAa,CAAC,MAAQ,SAAW,SAAW,CAAC,CAAC,KAAO,OAAO,KAAO,6BAMtKJ,GAAG,+CAA+C,WAChD,IACIwD,EAAM,EACGlD,EAAWhD,MAFb,qEAEyB,MAAM,SAACiB,EAAMkF,GAC/CD,OAEFtD,OAAOsD,GAAKnD,QAAQ,SAUxBP,SAAS,aAAa,WACpBE,GAAG,gEAAgE,WACjE,IAAIW,EAAO,4DACPV,EAASK,EAAWhD,MAAMqD,GAC1B+C,EAAepD,EAAW1C,QAAQqC,GACtCC,OAAOwD,GAAcrD,QAAQM,MAG/BX,GAAG,qDAAqD,WACtD,IACIC,EAASK,EAAWhD,MADb,sEAEPqG,EAAUrD,EAAW1C,QAAQqC,GAAQ,SAAC1B,GACvB,MAAdA,EAAKzF,OACNyF,EAAKV,WAAkB,MAAI,aAG/BqC,OAAOyD,GAAStD,QAAQ,6EAS5BP,SAAS,WAAW,WAClBE,GAAG,yCAAyC,WAC1C,IACIC,EAASK,EAAWhD,MADb,uIAEX2C,EAASK,EAAW+C,MAAMpD,GAE1BC,OAAOI,EAAW1C,QAAQqC,IAASI,QADd,0D,8ECrL3B,WAIAP,SAAS,WAAW,WAIlBA,SAAS,sBAAsB,WAC7BE,GAAG,iCAAiC,WAClC,IAAIxF,EAAO,EAAAiB,QAAQlB,iBAAiB,aACpC2F,OAAO1F,GAAM6F,QAAQ,UACrB7F,EAAO,EAAAiB,QAAQlB,iBAAiB,iBAChC2F,OAAO1F,GAAM6F,QAAQ,UACrB7F,EAAO,EAAAiB,QAAQlB,iBAAiB,kBAChC2F,OAAO1F,GAAM6F,QAAQ","file":"spec.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","/**\n * Utility class\n * \n * @export\n * @class Utility\n */\nexport class Utility {\n\n  /**\n   * Remove all white space from text\n   * \n   * @param {string} text \n   * @returns \n   * @memberof Utility\n   */\n  public removeWhitespace(text: string) {\n    var tab = '\\u0009';\n    var noBreakSpace = '\\u00A0';\n    var newLine = '\\n';\n    var CR = '\\u000D';\n    var LF = '\\u000A';\n\n    text = text.trim();\n    text = text.split(' ').join(\"\");\n    text = text.split(tab).join(\"\");\n    text = text.split(noBreakSpace).join(\"\");\n    text = text.split(newLine).join(\"\");\n    text = text.split(CR).join(\"\");\n    text = text.split(LF).join(\"\");\n    return text;\n  }\n\n\n  /**\n   * Check if a character is whitespace\n   * \n   * @param {string} ch \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isWhitespace(ch: string): boolean {\n    var tab = '\\u0009';\n    var noBreakSpace = '\\u00A0';\n    var newLine = '\\n';\n    var CR = '\\u000D';\n    var LF = '\\u000A';\n    return (ch === tab) || (ch === ' ') || (ch === noBreakSpace) \n      || (ch === newLine) || (ch === CR) || (ch === LF);\n  }\n\n\n  /**\n   * Determine if a string of text contains only whitespace characters\n   * \n   * @param {string} text \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public textOnlyContainsWhitespace(text: string) : boolean {\n    let isOnlyWhitespace = true;\n    if(!text) { return isOnlyWhitespace; }\n    for(let i = 0; i < text.length; i++) {\n      if(!this.isWhitespace(text[i])) {\n        isOnlyWhitespace = false;\n        break;\n      }\n    }\n    return isOnlyWhitespace;\n  }\n\n\n  /**\n   * Determine if a character is a letter\n   * \n   * @param {string} ch \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isLetter(ch: string): boolean {\n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n  }\n\n  /**\n   * Determine if the two characters are the start a html tag. HTML tags\n   * must start like <a <b \n   * \n   * @param {string} ch \n   * @param {string} nextCh \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isStartOfTag(ch: string, nextCh: string): boolean {\n    if(!ch || !nextCh) { return false; }\n    return (ch === \"<\" && this.isLetter(nextCh));\n  }\n\n\n  /**\n   * Determine if the two characters are the end of a html tag./\n   * \n   * @param {string} ch \n   * @param {string} nextCh \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isEndOfTag(ch: string, nextCh: string): boolean {\n    if(!ch || !nextCh) { return false; }\n    return (ch === \"<\" && nextCh === \"/\");\n  }\n\n\n  /**\n   * Determine if its the start of a html comment\n   * \n   * @param {string} text \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isStartOfComment(text: string): boolean {\n    return (text.indexOf('<!--') === 0);\n  }\n}\n\n// export as singleton\nlet utility = new Utility();\nexport { utility };","export const ELEMENT_TYPES = {\n  TAG: \"tag\",\n  TEXT: \"text\",\n  COMMENT: \"comment\"\n};\n\nexport const EMPTY_TAGS = {\n  \"area\": 1,\n  \"base\": 1,\n  \"basefont\": 1,\n  \"br\": 1,\n  \"col\": 1,\n  \"frame\": 1,\n  \"hr\": 1,\n  \"img\": 1,\n  \"input\": 1,\n  \"isindex\": 1,\n  \"link\": 1,\n  \"meta\": 1,\n  \"param\": 1,\n  \"embed\": 1\n};\n\nexport const MODE_TYPES = {\n  TEXT: 'text',\n  TAG: 'tag',\n  STYLE: 'style',\n  SCRIPT: 'script'\n};\n\nexport const TAG_TYPES = {\n  EMPTY: 'empty',\n  DEFAULT: 'default',\n  SCRIPT: 'script',\n  STYLE: 'style',\n  COMMENT: 'comment'\n};\n\nexport const QUOTE_TYPES = {\n  SINGLE: 1,\n  DOUBLE: 2\n};","import { utility } from './utility';\n\nconst PARSER_MODES = {\n  READING_ATTR_NAME: 'reading-attr-name',\n  READING_ATTR_VALUE: 'reading-attr-value'\n};\n\n/**\n * Parse attributes in a html tag\n * \n * @export\n * @class AttributeParser\n */\nexport class AttributeParser {\n  \n  // the state when parsing\n  private state: any = {\n    text: '',\n    currentPos: 0,\n    mode: PARSER_MODES.READING_ATTR_NAME,\n    attrName: '',\n    attrValue: ''\n  };\n\n\n  /**\n   * Reset the parser\n   * \n   * @private\n   * @memberof AttributeParser\n   */\n  private reset() {\n    this.state = {\n      text: '',\n      currentPos: 0,\n      mode: 'reading-attr-name',\n      attrName: '',\n      attrValue: ''\n    };\n  }\n\n\n  /**\n   * Get the next character in the text string\n   * \n   * @private\n   * @returns {string} \n   * @memberof AttributeParser\n   */\n  private getNextChar(): string {\n    let ch = null;\n    if(this.state.currentPos < this.state.text.length) {\n      ch = this.state.text.charAt(this.state.currentPos);\n      this.state.currentPos++;\n    }\n    return ch;\n  }\n\n\n  /**\n   * Parse the text of attributes\n   * \n   * @private\n   * @param {string} text \n   * @returns {{ [key: string]: any }} \n   * @memberof AttributeParser\n   */\n  private _parse(text: string): { [key: string]: any } {\n    let attr = {};\n    this.state.text = text;\n    while(true) {\n      let ch = this.getNextChar();\n      if(ch === null) { \n        if(this.state.attrName) {\n          attr[this.state.attrName] = (this.state.attrValue)\n            ? this.state.attrValue : null;\n        }\n        break; \n      }\n      if(this.state.mode === PARSER_MODES.READING_ATTR_NAME) {\n        this.handleReadingAttrName(ch, attr);\n      } else if(this.state.mode === PARSER_MODES.READING_ATTR_VALUE) {\n        this.handleReadingAttrValue(ch, attr);\n      }\n    }\n    return attr;\n  }\n\n\n  /**\n   * Handle getting the next character when reading the attribute name\n   * \n   * @private\n   * @param {string} ch \n   * @param {any} attr \n   * @memberof AttributeParser\n   */\n  private handleReadingAttrName(ch: string, attr) {\n    if(ch === '=') {\n      // end of the attribute name\n      this.state.mode = PARSER_MODES.READING_ATTR_VALUE;\n    } else if(ch === '/') {\n      // not an attribute, probably just an end tag, like <input />\n      // do nothing\n    } else if(utility.isWhitespace(ch)) {\n      // possibily be an attribute without a value\n      if(this.state.attrName) {\n        attr[this.state.attrName] = null;\n        this.state.attrName = '';\n      }\n    } else {\n      this.state.attrName = this.state.attrName + ch;\n    }\n  }\n\n\n  /**\n   * Handle getting the next character when reading the attribute value\n   * \n   * @private\n   * @param {string} ch \n   * @param {any} attr \n   * @memberof AttributeParser\n   */\n  private handleReadingAttrValue(ch: string, attr) {\n    if(utility.isWhitespace(ch)) {\n      let firstCh = this.state.attrValue[0];\n      let lastCh = this.state.attrValue[this.state.attrValue.length - 1];\n      if((firstCh === \"'\" || firstCh === '\"') && firstCh !== lastCh) {\n        // we must be dealing with a whitespace in a string, something like\n        // class=\"one two\"\n        this.state.attrValue = this.state.attrValue + ch;\n      } else {\n        attr[this.state.attrName] = this.state.attrValue;\n        this.state.mode = PARSER_MODES.READING_ATTR_NAME;\n        this.state.attrName = '';\n        this.state.attrValue = '';\n      }\n    } else {\n      this.state.attrValue = this.state.attrValue + ch;\n    }\n  }\n\n\n  /**\n   * Parse a html tag for attributes\n   * \n   * @param {string} tag \n   * @returns \n   * @memberof AttributeParser\n   */\n  public parse(tag: string) {\n    this.reset();\n    let attr = {};\n    let posOfFirstSpace = tag.indexOf(\" \");\n    let posOfGreaterThan = tag.lastIndexOf(\">\");\n    if(posOfFirstSpace > -1 && posOfFirstSpace < posOfGreaterThan) {\n      // we possibiliy have attributes\n      let text = tag.substring(posOfFirstSpace, posOfGreaterThan);\n      text = text.trim();\n      attr = this._parse(text);\n    }\n    return attr;\n  }\n\n\n  /**\n   * Reverse the output of the parse function back to a string of attributes\n   * \n   * @param {{ [key: string]: any}} attributes \n   * @returns {string} \n   * @memberof AttributeParser\n   */\n  public reverse(attributes: { [key: string]: any}): string {\n    let textAttr = '';\n    for(let key in attributes) {\n      if(attributes[key] === null) {\n        textAttr += ' ' + key;\n      } else {\n        textAttr += ' ' + key + '=' + attributes[key];\n      }\n    }\n    return textAttr.trim();\n  }\n}","import { iHtmlElement, iCleanOptions } from './interfaces';\nimport { ELEMENT_TYPES, TAG_TYPES } from './constants';\nimport { utility } from './utility';\n\n/**\n * Clean up the array of node elements returned from the HtmlParser.parse()\n * function\n * \n * @export\n * @class CleanParser\n */\nexport class CleanParser {\n  private removeEmptyTags;\n  private removeEmptyTextNodes;\n\n\n  /**\n   * Set the options for the parser\n   * \n   * @private\n   * @param {iCleanOptions} options \n   * @memberof CleanParser\n   */\n  private setOptions(options: iCleanOptions) {\n    options = options || {};\n    this.removeEmptyTags = (typeof options.removeEmptyTags !== 'undefined')\n      ? options.removeEmptyTags : true;\n    this.removeEmptyTextNodes = \n      (typeof options.removeEmptyTextNodes !== 'undefined')\n      ? options.removeEmptyTextNodes : true;\n  }\n\n\n  /**\n   * Remove text nodes that only contain whitespace\n   * \n   * @private\n   * @param {number} index \n   * @param {iHtmlElement[]} nodes \n   * @returns {void} \n   * @memberof CleanParser\n   */\n  private parseAndRemoveEmptyText(index: number, nodes: iHtmlElement[]): void {\n    if(index >= nodes.length) {\n      return;\n    }\n    let node = nodes[index];\n    if(node.type === ELEMENT_TYPES.TEXT \n    && utility.textOnlyContainsWhitespace(node.data)) {\n      nodes.splice(index, 1);\n      index--;\n    } else if(node.type === ELEMENT_TYPES.TAG && node.children\n    && node.children.length > 0) {\n      this.parseAndRemoveEmptyText(0, node.children);\n    }\n    this.parseAndRemoveEmptyText(++index, nodes);\n  }\n\n\n  /**\n   * Remove tag elements that are empty\n   * \n   * @private\n   * @param {number} index \n   * @param {iHtmlElement[]} nodes \n   * @returns {void} \n   * @memberof CleanParser\n   */\n  private parseAndRemoveEmptyTags(index: number, nodes: iHtmlElement[]): void {\n    if(index >= nodes.length) {\n      return;\n    }\n    let node = nodes[index];\n    if(node.type === ELEMENT_TYPES.TAG) {\n      if(node.children && node.children.length > 0) {\n        this.parseAndRemoveEmptyTags(0, node.children);\n      } \n      let noChildern = (!node.children || node.children.length <= 0);\n      if(node.tagType === TAG_TYPES.DEFAULT && noChildern) {\n        nodes.splice(index, 1);\n        index--;\n      }\n    }\n    this.parseAndRemoveEmptyTags(++index, nodes);\n  }\n\n\n  /**\n   * Parse html element nodes to clean and remove unwanted tags\n   * \n   * @param {iHtmlElement[]} htmlNodes \n   * @param {iCleanOptions} [options] \n   * @returns {iHtmlElement[]} \n   * @memberof CleanParser\n   */\n  parse(htmlNodes: iHtmlElement[], options?: iCleanOptions): iHtmlElement[] {\n    this.setOptions(options);\n    if(this.removeEmptyTextNodes) {\n      this.parseAndRemoveEmptyText(0, htmlNodes);\n    }\n    if(this.removeEmptyTags) {\n      this.parseAndRemoveEmptyTags(0, htmlNodes);\n    }\n    return htmlNodes;\n  }\n}\n","export { ELEMENT_TYPES, TAG_TYPES } from './constants';\nexport { iHtmlElement, iCleanOptions } from './interfaces';\nexport { HtmlParser } from './html-parser';","\n// Our webpack.unit.tests.config.js file uses this to require all unit test files\n// so they can be tested in a browser for debugging\n\n// require all test files\nvar testsContext = require.context('../unit', true, /.spec$/);\ntestsContext.keys().forEach(testsContext);\n","var map = {\n\t\"./attribute-parser.spec\": 7,\n\t\"./clear-parser.spec\": 8,\n\t\"./html-parser.spec\": 10,\n\t\"./utility.spec\": 11\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 6;","import { AttributeParser } from '../../src/attribute-parser';\n\n/**\n * Attribute parser\n */\ndescribe('Attribute parser', () => {\n  let attrParser = new AttributeParser();\n\n  /**\n   * parse()\n   */\n  describe('parse()', () => {\n    it('should parse attributes with double quotes', () => {\n      let tag = '<p class=\"class-one\" custom-attr=\"one two\" txt=\"\\'one\\'\">';\n      let expectedResult = {\"class\":\"\\\"class-one\\\"\",\"custom-attr\":\"\\\"one two\\\"\",\"txt\":\"\\\"'one'\\\"\"};\n      let output = attrParser.parse(tag);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    it('should work with single quotes', () => {\n      let tag = \"<span class='cls' cus-attr='one two'>\";\n      let expectedResult = {\"class\":\"'cls'\",\"cus-attr\":\"'one two'\"};\n      let output = attrParser.parse(tag);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    it('should handle values with no quotes', () => {\n      let tag = \"<div show=true hide=false>\";\n      let expectedResult = {\"show\":\"true\",\"hide\":\"false\"};\n      let output = attrParser.parse(tag);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    it('should work with attributes with no values', () => {\n      let tag = \"<input required cus='one' />\";\n      let expectedResult = {\"required\":null,\"cus\":\"'one'\"};\n      let output = attrParser.parse(tag);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    it('should handle no attributes', () => {\n      let tag = \"<div>\";\n      let output = attrParser.parse(tag);\n      expect(JSON.stringify(output)).toEqual(\"{}\");\n      tag = \"<br/>\";\n      output = attrParser.parse(tag);\n      expect(JSON.stringify(output)).toEqual(\"{}\");\n      tag = \"<br />\";\n      output = attrParser.parse(tag);\n      expect(JSON.stringify(output)).toEqual(\"{}\");\n    });\n\n    it('should parse complex attributes', () => {\n      let attrParser = new AttributeParser();\n      let tag = \"<p class='abc db' aria-label=\\\"Easy one two\\\" custom=\\\"'text'\\\" val='' required custom-again=true abc-d='1'>\";\n      let expectedResult = {\"class\":\"'abc db'\",\"aria-label\":\"\\\"Easy one two\\\"\",\"custom\":\"\\\"'text'\\\"\",\"val\":\"''\",\"required\":null,\"custom-again\":\"true\",\"abc-d\":\"'1'\"};\n      let output = attrParser.parse(tag);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    it('should parse attributes over different lines', () => {\n      let tag = `<p class=\"hi\"\n        custom='123' required \n        cust=true >`;\n      let expectedResult = {\"class\":\"\\\"hi\\\"\",\"custom\":\"'123'\",\"required\":null,\"cust\":\"true\"};\n      let output = attrParser.parse(tag);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    it('should parse attributes with greater than symbol in attribute text', () => {\n      let tag = \"<img alt='5>6' custom='d<f' />\";\n      let output = attrParser.parse(tag);\n      let expectedResult = {\"alt\":\"'5>6'\",\"custom\":\"'d<f'\"};\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n  });\n\n\n\n  /**\n   * reverse()\n   */\n  describe('reverse()', () => {\n    it('should reverse attributes object returned from parse function', () => {\n      let tag = \"<p class='one two' required custom=\\\"hi\\\">\";\n      let expectedResult = \"class='one two' required custom=\\\"hi\\\"\";\n      let output = attrParser.parse(tag);\n      let textAttr = attrParser.reverse(output);\n      expect(textAttr).toEqual(expectedResult);\n    });\n  });\n});","import { CleanParser } from '../../src/clean-parser';\nimport { HtmlParser } from '../../src';\nimport { iCleanOptions } from '../../src/interfaces';\n\n/**\n * CleanParser service\n */\ndescribe('CleanParser', () => {\n  let htmlParser = new HtmlParser();\n  let cleanParser = new CleanParser();\n\n\n  /**\n   * parse()\n   */\n  describe('parse()', () => {\n    it('should remove empty tags (basic)', () => {\n      let html = \"<div>hi <div><span></span></div></div>\";\n      let output = htmlParser.parse(html);\n      output = cleanParser.parse(output, {\n        removeEmptyTextNodes: false\n      });\n      let expectedResult = \"<div>hi </div>\";\n      expect(htmlParser.reverse(output)).toEqual(expectedResult);\n    });\n\n    it('should remove empty tags', () => {\n      let html = \"<div>hi <span></span> there, <br /> how are you<p></p></div>\";\n      let output = htmlParser.parse(html);\n      output = cleanParser.parse(output, {\n        removeEmptyTextNodes: false\n      });\n      let expectedResult = \"<div>hi  there, <br /> how are you</div>\";\n      expect(htmlParser.reverse(output)).toEqual(expectedResult);\n    });\n\n    it('should remove empty text nodes', () => {\n      let html = \"<div><span></span>hi<span> </span> </div>\";\n      let output = htmlParser.parse(html);\n      output = cleanParser.parse(output, {\n        removeEmptyTags: false\n      });\n      let expectedResult = \"<div><span></span>hi<span></span></div>\";\n      expect(htmlParser.reverse(output)).toEqual(expectedResult);\n    });\n  });\n});","import { utility } from './utility';\nimport {\n  ELEMENT_TYPES,\n  EMPTY_TAGS,\n  MODE_TYPES,\n  TAG_TYPES,\n  QUOTE_TYPES\n} from './constants';\nimport { \n  iHtmlElement, \n  iSearchTagResult, \n  iState, \n  iCleanOptions \n} from './interfaces';\nimport { AttributeParser } from './attribute-parser';\nimport { CleanParser } from './clean-parser';\n\n\n/**\n * Parse html string into an array of json objects that represent html elements\n * \n * @export\n * @class HtmlParser\n */\nexport class HtmlParser {\n\n  // the state when parsing\n  private state: iState;\n  private errorCb: (err: Error) => void = null;\n  private addNodeCb: (nodeBeingAdded: iHtmlElement, \n    parentElement: iHtmlElement) => void = null;\n  private stringifyNodeCb: (node: iHtmlElement) => void = null;\n  \n\n  /**\n   * Reset the parser\n   * \n   * @private\n   * @memberof HtmlParser\n   */\n  private reset() {\n    this.state = {\n      mode: MODE_TYPES.TEXT,\n      html: '',\n      currentPos: 0,\n      output: []\n    };\n  }\n\n\n  /**\n   * Add a html node element to our output object\n   * \n   * @private\n   * @param {iHtmlElement} newNode \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private addNodeElement(newNode: iHtmlElement, currentElement: iHtmlElement) {\n    if(this.addNodeCb) {\n      this.addNodeCb(newNode, currentElement);\n    }\n    if(currentElement) {\n      if(!currentElement.children) { currentElement.children = []; }\n      currentElement.children.push(newNode);\n    } else {\n      this.state.output.push(newNode);\n    }\n  }\n\n\n  /**\n   * Create a text node\n   * \n   * @private\n   * @param {string} text \n   * @returns {iHtmlElement} \n   * @memberof HtmlParser\n   */\n  private createTextNode(text: string): iHtmlElement {\n    return {\n      type: ELEMENT_TYPES.TEXT,\n      data: text\n    };\n  }\n\n\n  /**\n   * Create a comment node\n   * \n   * @private\n   * @param {string} comment \n   * @returns {iHtmlElement} \n   * @memberof HtmlParser\n   */\n  private createCommentNode(comment: string): iHtmlElement {\n    return {\n      type: ELEMENT_TYPES.COMMENT,\n      data: comment\n    };\n  }\n\n\n  /**\n   * Create a tag node\n   * \n   * @private\n   * @param {string} tag \n   * @returns {iHtmlElement} \n   * @memberof HtmlParser\n   */\n  private createTagNode(tag: string): iHtmlElement {\n    let posOfFirstSpace = tag.indexOf(\" \");\n    let posOfGreaterThan = tag.indexOf(\">\");\n    let endIndex = (posOfFirstSpace > -1 && posOfFirstSpace < posOfGreaterThan)\n      ? posOfFirstSpace : posOfGreaterThan;\n    let name = tag.substring(1, endIndex);\n    name = utility.removeWhitespace(name);\n    return {\n      type: ELEMENT_TYPES.TAG,\n      tagType: this.getTagType(name),\n      name: name,\n      attributes: this.parseAttributes(tag),\n      children: [] \n    };\n  }\n\n\n  /**\n   * Get the type of tag\n   * \n   * @private\n   * @param {string} name \n   * @returns {string} \n   * @memberof HtmlParser\n   */\n  private getTagType(name: string): string {\n    name = name.toLowerCase();\n    if(EMPTY_TAGS[name]) {\n      return TAG_TYPES.EMPTY;\n    } else if(name === TAG_TYPES.STYLE) {\n      return TAG_TYPES.STYLE;\n    } else if(name === TAG_TYPES.SCRIPT) {\n      return TAG_TYPES.SCRIPT;\n    } else if(name === TAG_TYPES.COMMENT) {\n      return TAG_TYPES.COMMENT;\n    }\n    return TAG_TYPES.DEFAULT;\n  }\n\n\n  /**\n   * Get the next tag from a text string, it could be a start or end tag\n   * \n   * @private\n   * @param {string} text \n   * @returns {iSearchTagResult} \n   * @memberof HtmlParser\n   */\n  private getNextTag(text: string): iSearchTagResult {\n    let pos = 0;\n    while(pos < text.length) {\n      if(utility.isStartOfTag(text[pos], text[pos + 1])) {\n        return {\n          type: 'start',\n          pos: pos \n        };\n      } else if(utility.isEndOfTag(text[pos], text[pos + 1])) {\n        return {\n          type: 'end',\n          pos: pos\n        }\n      } else if(utility.isStartOfComment(text.substr(pos))) {\n        return {\n          type: 'comment',\n          pos: pos\n        }\n      }\n      pos++;\n    }\n    return { type: 'no-tag' };\n  }\n\n\n  /**\n   * Parse for text\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private parseText(currentElement: iHtmlElement) {\n    let nextText = this.state.html.substring(this.state.currentPos);\n    let tagResult = this.getNextTag(nextText);\n    if(tagResult.type === 'start') {\n      this.handleStartTagInText(tagResult, nextText, currentElement);\n    } else if(tagResult.type === 'end') {\n      this.handleEndTagInText(tagResult, nextText, currentElement);\n    } else if(tagResult.type === 'comment') {\n      this.handleCommentInText(tagResult, nextText, currentElement);\n    }else {\n      // no tag found\n      if(nextText.length > 0) {\n        let textNode = this.createTextNode(nextText);\n        this.addNodeElement(textNode, currentElement);\n      }\n    }\n  }\n\n\n  /**\n   * Handle finding the start tag of a html element\n   * \n   * @private\n   * @param {iSearchTagResult} tagResult \n   * @param {string} nextText \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private handleStartTagInText(tagResult: iSearchTagResult, \n  nextText: string, currentElement: iHtmlElement): void {\n    if(tagResult.pos > 0) {\n      // there must be text before our html start tag\n      let text = nextText.substring(0, tagResult.pos);\n      let textNode = this.createTextNode(text);\n      this.addNodeElement(textNode, currentElement);\n    }\n    // need to now parse the html tag\n    this.state.mode = MODE_TYPES.TAG;\n    this.state.currentPos = this.state.currentPos + tagResult.pos;\n    this._parse(currentElement);\n  }\n\n\n  /**\n   * Handing finding the end tag of a html element\n   * \n   * @private\n   * @param {iSearchTagResult} tagResult \n   * @param {string} nextText \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private handleEndTagInText(tagResult: iSearchTagResult, \n  nextText: string, currentElement: iHtmlElement): void {\n    if(tagResult.pos > 0) {\n      // there must be text before our html end tag\n      let text = nextText.substring(0, tagResult.pos);\n      let textNode = this.createTextNode(text);\n      this.addNodeElement(textNode, currentElement);\n    }\n    // validate the end tag is correct\n    let posEndTag = nextText.indexOf('>', tagResult.pos) + 1;\n    let tagText = nextText.substring(tagResult.pos, posEndTag);\n    let tagName = tagText.replace(\"</\", \"\").replace(\">\", \"\");\n    if(!currentElement) {\n      let err = new Error('No start tag for end tag: ' + tagName);\n      if(this.errorCb) { this.errorCb(err); }\n    }\n    if(currentElement.name.toLowerCase() !== tagName.toLowerCase()) {\n      let err = Error('Start tag (' + currentElement.name + ') and end tag '\n      + '(' + tagName + ') do not match');\n      if(this.errorCb) { this.errorCb(err); }\n    }\n    this.state.mode = MODE_TYPES.TEXT;\n    this.state.currentPos = this.state.currentPos + posEndTag;\n    let parentElement = currentElement.parentElement;\n    delete currentElement.parentElement;\n    this._parse(parentElement);\n  }\n\n\n  /**\n   * Handle finding a comment in text\n   * \n   * @private\n   * @param {iSearchTagResult} tagResult \n   * @param {string} nextText \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private handleCommentInText(tagResult: iSearchTagResult, \n  nextText: string, currentElement: iHtmlElement) {\n    if(tagResult.pos > 0) {\n      // there must be text before our html end tag\n      let text = nextText.substring(0, tagResult.pos);\n      let textNode = this.createTextNode(text);\n      this.addNodeElement(textNode, currentElement);\n    }\n    let posEndCommentTag = nextText.indexOf('-->');\n    if(!posEndCommentTag) {\n      let err = new Error('Comment does not have an end tag');\n      if(this.errorCb) { this.errorCb(err); }\n    }\n    let commentText = nextText.substring(tagResult.pos + 4, posEndCommentTag);\n    let commentNode = this.createCommentNode(commentText);\n    this.addNodeElement(commentNode, currentElement);\n    this.state.mode = MODE_TYPES.TEXT;\n    this.state.currentPos = this.state.currentPos + (posEndCommentTag + 3);\n    this._parse(currentElement);\n  }\n\n\n  /**\n   * Parse a tag\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private parseTag(currentElement: iHtmlElement) {\n    let nextText = this.state.html.substring(this.state.currentPos);\n    let posEndTag = this.findPositionOfClosingTag(nextText) + 1;\n    let tagText = nextText.substring(0, posEndTag);\n    let tagNode = this.createTagNode(tagText);\n    // move to the end of our start tag\n    this.state.currentPos = this.state.currentPos + posEndTag;\n    this.addNodeElement(tagNode, currentElement);\n    this.state.mode = MODE_TYPES.TEXT;\n    if(tagNode.tagType === TAG_TYPES.EMPTY) {\n      // empty tags can not have children\n      this._parse(currentElement);\n    } else if(tagNode.tagType === TAG_TYPES.STYLE) {\n      this.state.mode = MODE_TYPES.STYLE;\n      tagNode.parentElement = currentElement;\n      this._parse(tagNode);\n    } else if(tagNode.tagType === TAG_TYPES.SCRIPT) {\n      this.state.mode = MODE_TYPES.SCRIPT;\n      tagNode.parentElement = currentElement;\n      this._parse(tagNode);\n    } else {\n      tagNode.parentElement = currentElement;\n      this._parse(tagNode);\n    }\n  }\n\n\n  /**\n   * Find the position of the greater than symbol for a html tag element. \n   * \n   * @private\n   * @param {string} text \n   * @returns \n   * @memberof HtmlParser\n   */\n  private findPositionOfClosingTag(text: string) {\n    let posOfFirstSpace = text.indexOf(\" \");\n    let pos = (posOfFirstSpace > -1) ? posOfFirstSpace + 1 : 0;\n    let posOfGreaterThan = text.indexOf(\">\");\n    if(posOfGreaterThan < pos) {\n      return posOfGreaterThan;\n    }\n    let quoteType = null;\n    let insideQuote = false;\n    while(true) {\n      let ch = (pos < text.length) ? text[pos] : null;\n      if(ch === '>' && !insideQuote) {\n        return pos;\n      } else if(ch === \"'\") {\n        if(insideQuote && quoteType === QUOTE_TYPES.SINGLE) {\n          insideQuote = false;\n        } else if(!insideQuote) {\n          insideQuote = true;\n          quoteType = QUOTE_TYPES.SINGLE;\n        }\n      } else if(ch === '\"') {\n        if(insideQuote && quoteType === QUOTE_TYPES.DOUBLE) {\n          insideQuote = false;\n        } else if(!insideQuote) {\n          insideQuote = true;\n          quoteType = QUOTE_TYPES.DOUBLE;\n        }\n      } else if(ch === null) {\n        // if we get here, the html must be really bad\n        break;\n      }\n      pos++;\n    }\n    return text.length - 1;\n  }\n\n\n  /**\n   * Parse for attributes in a html tag\n   * \n   * @private\n   * @param {string} tag \n   * @returns {{ [key: string]: any }} \n   * @memberof HtmlParser\n   */\n  private parseAttributes(tag: string): { [key: string]: any } {\n    let attrParser = new AttributeParser();\n    return attrParser.parse(tag);\n  }\n\n\n  /**\n   * Parse a script tag like: <script> or <style>\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @param {string} endTag \n   * @memberof HtmlParser\n   */\n  private parseScript(currentElement: iHtmlElement, endTag: string) {\n    let nextText = this.state.html.substring(this.state.currentPos);\n    let posOfEndTag = nextText.indexOf(endTag);\n    if(posOfEndTag < 0) {\n      let err = new Error('Script (' + currentElement.name + ' ) does not have ' +\n      'an end tag');\n      if(this.errorCb) { this.errorCb(err); }\n    }\n    let scriptContent = nextText.substring(0, posOfEndTag);\n    let textNode = this.createTextNode(scriptContent);\n    this.addNodeElement(textNode, currentElement);\n    this.state.currentPos = this.state.currentPos \n      + (posOfEndTag + endTag.length);\n    this.state.mode = MODE_TYPES.TEXT;\n    let parentElement = currentElement.parentElement;\n    delete currentElement.parentElement;\n    this._parse(parentElement);\n  }\n\n\n  /**\n   * Keep parsing the html string\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private _parse(currentElement: iHtmlElement) {\n    switch(this.state.mode) {\n      case MODE_TYPES.TEXT:\n        this.parseText(currentElement);\n        break;\n      case MODE_TYPES.TAG:\n        this.parseTag(currentElement);\n        break;\n      case MODE_TYPES.STYLE:\n        this.parseScript(currentElement, \"</style>\");\n        break;\n      case MODE_TYPES.SCRIPT:\n        this.parseScript(currentElement, \"</script>\");\n        break;\n    }\n  }\n\n\n  /**\n   * Parse a html string\n   * \n   * @param {string} html \n   * @param {Function} cb\n   * @returns {iHtmlElement []} \n   * @memberof HtmlParser\n   */\n  public parse(html: string, errorCb?: (err: Error) => void,\n  addNodeCb?: (nodeBeingAdded: iHtmlElement, parentElement: iHtmlElement) => void)\n  : iHtmlElement [] {\n    this.errorCb = (errorCb) ? errorCb : null;\n    this.addNodeCb = (addNodeCb) ? addNodeCb : null;\n    this.reset();\n    this.state.html = html;\n    this._parse(null);\n    return this.state.output;\n  }\n\n\n  /**\n   * Reverse the output from the parse function back to html string\n   * \n   * @param {iHtmlElement[]} htmlNodes \n   * @returns {string} \n   * @memberof HtmlParser\n   */\n  public reverse(htmlNodes: iHtmlElement[], \n  stringifyNodeCb?: (node: iHtmlElement) => void): string {\n    this.stringifyNodeCb = (stringifyNodeCb) ? stringifyNodeCb : null;\n    return this.reverseNodes(0, htmlNodes, '');\n  }\n\n\n  /**\n   * Reverse an array of html element nodes into a html string\n   * \n   * @private\n   * @param {number} index \n   * @param {iHtmlElement[]} htmlNodes \n   * @param {string} html \n   * @returns \n   * @memberof HtmlParser\n   */\n  private reverseNodes(index: number, htmlNodes: iHtmlElement[], html: string) {\n    if(index >= htmlNodes.length) {\n      return html;\n    }\n    let node = htmlNodes[index];\n    if(this.stringifyNodeCb) { this.stringifyNodeCb(node); }\n    if(node.type === ELEMENT_TYPES.TEXT) {\n      html += node.data;\n    } else if(node.type === ELEMENT_TYPES.COMMENT) {\n      html += '<!--' + node.data + '-->';\n    } else {\n      let attrParser = new AttributeParser();\n      let textAttr = attrParser.reverse(node.attributes);\n      textAttr = (textAttr.length > 0) ? ' ' + textAttr : textAttr;\n      // tag type\n      if(node.tagType === TAG_TYPES.EMPTY) {\n        html += '<' + node.name + textAttr + ' />';\n      } else {\n        html += '<' + node.name + textAttr + '>';\n        if(node.children && node.children.length > 0) {\n          let newHtml = this.reverseNodes(0, node.children, '');\n          html += newHtml;\n        }\n        html += '</' + node.name + '>';\n      }\n    }\n    index++;\n    return this.reverseNodes(index, htmlNodes, html);\n  }\n\n\n  /**\n   * Parse html element nodes to clean and remove unwanted tags\n   * \n   * @param {iHtmlElement[]} nodes \n   * @param {iCleanOptions} options \n   * @returns {iHtmlElement[]} \n   * @memberof HtmlParser\n   */\n  public clean(nodes: iHtmlElement[], options?: iCleanOptions): iHtmlElement[] {\n    let cleanParser = new CleanParser();\n    return cleanParser.parse(nodes, options);\n  }\n}","import {\n  HtmlParser,\n  ELEMENT_TYPES,\n  iHtmlElement\n} from '../../src';\n\n/**\n * HtmlParser\n */\ndescribe('HtmlParser', () => {\n  let htmlParser = new HtmlParser();\n\n  /**\n   * parse()\n   */\n  describe('parse()', () => {\n    // plain text\n    it('should parse plain text', () => {\n      let html = \"plain text \";\n      let expectedResult = [{\"type\":\"text\",\"data\":\"plain text \"}];\n      let output = htmlParser.parse(html);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    // plain text with tag\n    it('should parse plain text with tag', () => {\n      let html = \"plain text <br />\";\n      let expectedResult = [{\"type\":\"text\",\"data\":\"plain text \"},{\"type\":\"tag\",\"tagType\":\"empty\",\"name\":\"br\",\"attributes\":{},\"children\":[]}];\n      let output = htmlParser.parse(html);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    // html comment\n    it('should handle html comment', () => {\n      let html = \"<div><!--This is not seen-->Hello world!</div>\";\n      let expectedResult = [{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"div\",\"attributes\":{},\"children\":[{\"type\":\"comment\",\"data\":\"This is not seen\"},{\"type\":\"text\",\"data\":\"Hello world!\"}]}];\n      let output = htmlParser.parse(html);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    // script tag\n    it('should parse script tag', () => {\n      let html = \"<body><script type=\\\"javascript/text\\\">var a = ( 5 > 2) ? 3 : 3;</script></body>\";\n      let output = htmlParser.parse(html);\n      let expectedResult = [{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"body\",\"attributes\":{},\"children\":[{\"type\":\"tag\",\"tagType\":\"script\",\"name\":\"script\",\"attributes\":{\"type\":\"\\\"javascript/text\\\"\"},\"children\":[{\"type\":\"text\",\"data\":\"var a = ( 5 > 2) ? 3 : 3;\"}]}]}];\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    // style tag\n    it('should parse style tag', () => {\n      let html = \"<body><style>body > p {}</style></body>\";\n      let output = htmlParser.parse(html);\n      let expectedResult = [{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"body\",\"attributes\":{},\"children\":[{\"type\":\"tag\",\"tagType\":\"style\",\"name\":\"style\",\"attributes\":{},\"children\":[{\"type\":\"text\",\"data\":\"body > p {}\"}]}]}];\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    // nested tags\n    it('should parse nested tags', () => {\n      let html = \"<div><div><p> hi<span> there</span></p></div></div>\";\n      let output = htmlParser.parse(html);\n      let expectedResult = [{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"div\",\"attributes\":{},\"children\":[{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"div\",\"attributes\":{},\"children\":[{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"p\",\"attributes\":{},\"children\":[{\"type\":\"text\",\"data\":\" hi\"},{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"span\",\"attributes\":{},\"children\":[{\"type\":\"text\",\"data\":\" there\"}]}]}]}]}];\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    // tags with attributes\n    it('should parse tags with attributes', () => {\n      let html = \"<div class='one'><input required /></div>\";\n      let output = htmlParser.parse(html);\n      let expectedResult = [{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"div\",\"attributes\":{\"class\":\"'one'\"},\"children\":[{\"type\":\"tag\",\"tagType\":\"empty\",\"name\":\"input\",\"attributes\":{\"required\":null},\"children\":[]}]}];\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    // invliad html\n    it('should pass error for invalid html', () => {\n      let html = \"<div><p>hi</div>\";\n      let errorCalled = 0;\n      let output = htmlParser.parse(html, (err) => {\n        errorCalled++;\n      });\n      expect(errorCalled).toBeGreaterThan(0);\n    });\n\n    // tags in capital letter\n    it('should parse tags with capital letters', () => {\n      let html = \"<SPAN><p>hi</P> there</SPAN>\";\n      let expectedResult = [{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"SPAN\",\"attributes\":{},\"children\":[{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"p\",\"attributes\":{},\"children\":[{\"type\":\"text\",\"data\":\"hi\"}]},{\"type\":\"text\",\"data\":\" there\"}]}];\n      let output = htmlParser.parse(html);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    // custom tags, like: <cust-tag>Hello</cust-tag>\n    it('should parse custom tags', () => {\n      let html = \"<cust-tag>hello</cust-tag>\";\n      let output = htmlParser.parse(html);\n      let expectedResult = [{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"cust-tag\",\"attributes\":{},\"children\":[{\"type\":\"text\",\"data\":\"hello\"}]}];\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    // text with < or > signs in it, like: <p> 5 > 3 </p>\n    it('should parse text content that has less than or greater than symbols', () => {\n      let html = \"<p> 5 > 3 and 2 < 4 </p>\";\n      let expectedResult = [{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"p\",\"attributes\":{},\"children\":[{\"type\":\"text\",\"data\":\" 5 > 3 and 2 < 4 \"}]}];\n      let output = htmlParser.parse(html);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    // handle greater or less than symbols in attribute values\n    it('should handle greater than symbol in attribute', () => {\n      let html = \"<img alt='5>6' custom='d<f' /><span class=d>f>hi</span>\";\n      let output = htmlParser.parse(html);\n      let expectedResult = [{\"type\":\"tag\",\"tagType\":\"empty\",\"name\":\"img\",\"attributes\":{\"alt\":\"'5>6'\",\"custom\":\"'d<f'\"},\"children\":[]},{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"span\",\"attributes\":{\"class\":\"d\"},\"children\":[{\"type\":\"text\",\"data\":\"f>hi\"}]}];\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n    // TODO: fix parser to handle this\n    it('should handle quotes in attributes', () => {\n      let html = \"<p custom=\\\"This's there ' s\\\"><span tag='\\\"hi there\\\"'></span></p>\";\n      let output = htmlParser.parse(html);\n      let expectedResult = [{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"p\",\"attributes\":{\"custom\":\"\\\"This's there ' s\\\"\"},\"children\":[{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"span\",\"attributes\":{\"tag\":\"'\\\"hi there\\\"'\"},\"children\":[]}]}];\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n\n    it('should parse tag split over lines', () => {\n      let html = `hi\n<p\n  class=\"one\">\n  a paragraph\n</p>`;\n      let expectedResult = [{\"type\":\"text\",\"data\":\"hi\\n\"},{\"type\":\"tag\",\"tagType\":\"default\",\"name\":\"p\",\"attributes\":{\"class\":\"\\\"one\\\"\"},\"children\":[{\"type\":\"text\",\"data\":\"\\n  a paragraph\\n\"}]}];\n      let output = htmlParser.parse(html);\n      expect(JSON.stringify(output)).toEqual(JSON.stringify(expectedResult));\n    });\n\n\n    it('should fire event each time a node is added', () => {\n      let html = \"<p class='one'>My <span>name is <strong>Nathan</strong></span></p>\";\n      let cnt = 0;\n      let output = htmlParser.parse(html, null, (node, parentNode) => {\n        cnt++;\n      });\n      expect(cnt).toEqual(6);\n    });\n  });\n\n\n\n\n  /**\n   * reverse()\n   */\n  describe('reverse()', () => {\n    it('should reverse output from the parse function back into html', () => {\n      let html = \"<div class='one'><p>hi <span>there</span></p><br /></div>\";\n      let output = htmlParser.parse(html);\n      let reversedHtml = htmlParser.reverse(output);\n      expect(reversedHtml).toEqual(html);\n    });\n\n    it('should fire event each time a node is stringified', () => {\n      let html = \"<p class='one'>My <span>name is <strong>Nathan</strong></span></p>\";\n      let output = htmlParser.parse(html);\n      let newHtml = htmlParser.reverse(output, (node) => {\n        if(node.name === 'p') {\n          node.attributes['class'] = \"'onne'\";\n        }\n      });\n      expect(newHtml).toEqual(\"<p class='onne'>My <span>name is <strong>Nathan</strong></span></p>\");\n    });\n  });\n\n\n\n  /**\n   * clean()\n   */\n  describe('clean()', () => {\n    it('should clean and remove unwanted html', () => {\n      let html = \"<div>\\n<p>\\n</p><p> Hello</p>\\n <div><span></span>\\n</div>\\n<div>hi <br><span></span>\\n</div><div><p><span> </span></p></div></div>\";\n      let output = htmlParser.parse(html);\n      output = htmlParser.clean(output);\n      let expectedResult = \"<div><p> Hello</p><div>hi <br /></div></div>\";\n      expect(htmlParser.reverse(output)).toEqual(expectedResult);\n    });\n  });\n});","import { utility } from '../../src/utility';\n/**\n * Utility\n */\ndescribe('Utility', () => {\n  /**\n   * removeWhitespace()\n   */\n  describe('removeWhitespace()', () => {\n    it('should remove all white space', () => {\n      let text = utility.removeWhitespace(\" nathan\\n\");\n      expect(text).toEqual(\"nathan\");\n      text = utility.removeWhitespace(\" \\u000D\\u000Anathan\\n\");\n      expect(text).toEqual(\"nathan\");\n      text = utility.removeWhitespace(\" \\u000D\\u000Anat han\\n\");\n      expect(text).toEqual(\"nathan\");\n    });\n  });\n});"],"sourceRoot":""}