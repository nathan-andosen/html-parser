{"version":3,"sources":["webpack:///webpack/bootstrap 14773a95cbfd630dbaed","webpack:///./src/attribute-parser.ts","webpack:///./src/constants.ts","webpack:///./spec/in-browser/index.js","webpack:///./spec/unit .spec$","webpack:///./spec/unit/attribute-parser.spec.ts","webpack:///./spec/unit/html-parser.spec.ts","webpack:///./src/index.ts","webpack:///./src/html-parser.ts","webpack:///./src/utility.ts"],"names":[],"mappings":"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","file":"spec.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 14773a95cbfd630dbaed","\n\nconst PARSER_MODES = {\n  READING_ATTR_NAME: 'reading-attr-name',\n  READING_ATTR_VALUE: 'reading-attr-value'\n};\n\n\nexport class AttributeParser {\n  \n  // the state when parsing\n  private state: any = {\n    text: '',\n    currentPos: 0,\n    mode: PARSER_MODES.READING_ATTR_NAME,\n    attrName: '',\n    attrValue: ''\n  };\n\n\n  /**\n   * Check if a character is whitespace\n   * \n   * @private\n   * @param {string} ch \n   * @returns \n   * @memberof AttributeParser\n   */\n  private isWhitespace(ch: string) {\n    var tab = '\\u0009';\n    var noBreakSpace = '\\u00A0';\n    var newLine = '\\n';\n    var CR = '\\u000D';\n    var LF = '\\u000A';\n    return (ch === tab) || (ch === ' ') || (ch === noBreakSpace) \n      || (ch === newLine) || (ch === CR) || (ch === LF);\n  }\n\n\n  /**\n   * Reset the parser\n   * \n   * @private\n   * @memberof AttributeParser\n   */\n  private reset() {\n    this.state = {\n      text: '',\n      currentPos: 0,\n      mode: 'reading-attr-name',\n      attrName: '',\n      attrValue: ''\n    };\n  }\n\n\n  /**\n   * Get the next character in the text string\n   * \n   * @private\n   * @returns {string} \n   * @memberof AttributeParser\n   */\n  private getNextChar(): string {\n    let ch = null;\n    if(this.state.currentPos < this.state.text.length) {\n      ch = this.state.text.charAt(this.state.currentPos);\n      this.state.currentPos++;\n    }\n    return ch;\n  }\n\n\n  /**\n   * Parse the text of attributes\n   * \n   * @private\n   * @param {string} text \n   * @returns {{ [key: string]: any }} \n   * @memberof AttributeParser\n   */\n  private _parse(text: string): { [key: string]: any } {\n    let attr = {};\n    this.state.text = text;\n    while(true) {\n      let ch = this.getNextChar();\n      if(ch === null) { \n        if(this.state.attrName) {\n          attr[this.state.attrName] = (this.state.attrValue)\n            ? this.state.attrValue : null;\n        }\n        break; \n      }\n      if(this.state.mode === PARSER_MODES.READING_ATTR_NAME) {\n        this.handleReadingAttrName(ch, attr);\n      } else if(this.state.mode === PARSER_MODES.READING_ATTR_VALUE) {\n        this.handleReadingAttrValue(ch, attr);\n      }\n    }\n    return attr;\n  }\n\n\n  /**\n   * Handle getting the next character when reading the attribute name\n   * \n   * @private\n   * @param {string} ch \n   * @param {any} attr \n   * @memberof AttributeParser\n   */\n  private handleReadingAttrName(ch: string, attr) {\n    if(ch === '=') {\n      // end of the attribute name\n      this.state.mode = PARSER_MODES.READING_ATTR_VALUE;\n    } else if(this.isWhitespace(ch)) {\n      // must be an attribute without a value\n      attr[this.state.attrName] = null;\n      this.state.attrName = '';\n    } else {\n      this.state.attrName = this.state.attrName + ch;\n    }\n  }\n\n\n  /**\n   * Handle getting the next character when reading the attribute value\n   * \n   * @private\n   * @param {string} ch \n   * @param {any} attr \n   * @memberof AttributeParser\n   */\n  private handleReadingAttrValue(ch: string, attr) {\n    if(this.isWhitespace(ch)) {\n      let firstCh = this.state.attrValue[0];\n      let lastCh = this.state.attrValue[this.state.attrValue.length - 1];\n      if((firstCh === \"'\" || firstCh === '\"') && firstCh !== lastCh) {\n        // we must be dealing with a whitespace in a string, something like\n        // class=\"one two\"\n        this.state.attrValue = this.state.attrValue + ch;\n      } else {\n        attr[this.state.attrName] = this.state.attrValue;\n        this.state.mode = PARSER_MODES.READING_ATTR_NAME;\n        this.state.attrName = '';\n        this.state.attrValue = '';\n      }\n    } else {\n      this.state.attrValue = this.state.attrValue + ch;\n    }\n  }\n\n\n  /**\n   * Parse a html tag for attributes\n   * \n   * @param {string} tag \n   * @returns \n   * @memberof AttributeParser\n   */\n  public parse(tag: string) {\n    this.reset();\n    let attr = {};\n    let posOfFirstSpace = tag.indexOf(\" \");\n    let posOfGreaterThan = tag.indexOf(\">\");\n    if(posOfFirstSpace > -1 && posOfFirstSpace < posOfGreaterThan) {\n      // we possibiliy have attributes\n      let text = tag.substring(posOfFirstSpace, posOfGreaterThan);\n      text = text.trim();\n      if(text.indexOf('/') < 0) {\n        attr = this._parse(text);\n      }\n    }\n    return attr;\n  }\n\n\n  /**\n   * Reverse the output of the parse function back to a string of attributes\n   * \n   * @param {{ [key: string]: any}} attributes \n   * @returns {string} \n   * @memberof AttributeParser\n   */\n  public reverse(attributes: { [key: string]: any}): string {\n    let textAttr = '';\n    for(let key in attributes) {\n      if(attributes[key] === null) {\n        textAttr += ' ' + key;\n      } else {\n        textAttr += ' ' + key + '=' + attributes[key];\n      }\n    }\n    return textAttr.trim();\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/attribute-parser.ts","export const ELEMENT_TYPES = {\n  TAG: \"tag\",\n  TEXT: \"text\",\n  COMMENT: \"comment\"\n};\n\nexport const EMPTY_TAGS = {\n  \"area\": 1,\n  \"base\": 1,\n  \"basefont\": 1,\n  \"br\": 1,\n  \"col\": 1,\n  \"frame\": 1,\n  \"hr\": 1,\n  \"img\": 1,\n  \"input\": 1,\n  \"isindex\": 1,\n  \"link\": 1,\n  \"meta\": 1,\n  \"param\": 1,\n  \"embed\": 1\n};\n\nexport const MODE_TYPES = {\n  TEXT: 'text',\n  TAG: 'tag',\n  STYLE: 'style',\n  SCRIPT: 'script'\n};\n\nexport const TAG_TYPES = {\n  EMPTY: 'empty',\n  DEFAULT: 'default',\n  SCRIPT: 'script',\n  STYLE: 'style',\n  COMMENT: 'comment'\n};\n\n\n// WEBPACK FOOTER //\n// ./src/constants.ts","\n// Our webpack.unit.tests.config.js file uses this to require all unit test files\n// so they can be tested in a browser for debugging\n\n// require all test files\nvar testsContext = require.context('../unit', true, /.spec$/);\ntestsContext.keys().forEach(testsContext);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./spec/in-browser/index.js\n// module id = 2\n// module chunks = 0","var map = {\n\t\"./attribute-parser.spec\": 4,\n\t\"./html-parser.spec\": 5\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 3;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./spec/unit .spec$\n// module id = 3\n// module chunks = 0","import { AttributeParser } from '../../src/attribute-parser';\n\ndescribe('Attribute parser', () => {\n\n  describe('parse()', () => {\n    // class=\"text lbl\" required spellcheck custom='10' custom-again=true\n    it('should parse attributes', () => {\n      let attrParser = new AttributeParser();\n      let tag = \"<p class='abc db' aria-label=\\\"Easy one two\\\" custom=\\\"'text'\\\" val='' required custom-again=true abc-d='1'>\";\n      console.log(tag);\n      let output = attrParser.parse(tag);\n      console.log(JSON.stringify(output, null, 2));\n      let output2 = attrParser.reverse(output);\n      console.log(output2);\n    });\n\n  });\n});\n\n\n// WEBPACK FOOTER //\n// ./spec/unit/attribute-parser.spec.ts","import {\n  HtmlParser,\n  ELEMENT_TYPES,\n  iHtmlElement\n} from '../../src';\n\n/**\n * HtmlParser\n */\ndescribe('HtmlParser', () => {\n\n  /**\n   * parse()\n   */\n  describe('parse()', () => {\n    \n    // // plain text\n    // it('should parse plain text', () => {\n    //   let html = \"plain text \";\n    //   let htmlParser = new HtmlParser();\n    //   let output = htmlParser.parse(html);\n    //   expect(output[0].type).toEqual(ELEMENT_TYPES.TEXT);\n    //   expect(output[0].data).toEqual(\"plain text \");\n    //   console.log(JSON.stringify(output, null, 2));\n    // });\n\n    // // plain text with tag\n    // it('should parse plain text with tag', () => {\n    //   let html = \"plain text <br />\";\n    //   let htmlParser = new HtmlParser();\n    //   let output = htmlParser.parse(html);\n    //   expect(output[0].type).toEqual(ELEMENT_TYPES.TEXT);\n    //   expect(output[0].data).toEqual(\"plain text \");\n    //   expect(output[1].name).toEqual(\"br\");\n    //   console.log(JSON.stringify(output, null, 2));\n    // });\n\n    // <p>basic</p>\n    fit('should parse basic tag', () => {\n      let html = \"<p class='a'>hi <!-- comment --><br></p>\";\n      // let html = \"<p>hi <span>there</span></p> bye\";\n      // let html = \"<body><p>hi</p><script type=\\\"text/javascript\\\">var a = '<div></div>';</script></body>\";\n      // let html = \"<p><!-- This is a comment -->Hello world!</p>\";\n      console.log(html);\n      let htmlParser = new HtmlParser();\n      let output = htmlParser.parse(html);\n      console.log(JSON.stringify(output, null, 2));\n      let htmlOutput = htmlParser.reverse(output);\n      console.log(htmlOutput);\n    });\n  });\n});\n\n\n// WEBPACK FOOTER //\n// ./spec/unit/html-parser.spec.ts","export * from './constants';\nexport * from './interfaces';\nexport * from './html-parser';\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import { utility } from './utility';\nimport {\n  ELEMENT_TYPES,\n  EMPTY_TAGS,\n  MODE_TYPES,\n  TAG_TYPES \n} from './constants';\nimport { iHtmlElement, iSearchTagResult, iState } from './interfaces';\nimport { AttributeParser } from './attribute-parser';\n\n\n/**\n * Parse html string into an array of json objects that represent html elements\n * \n * @export\n * @class HtmlParser\n */\nexport class HtmlParser {\n\n  // the state when parsing\n  private state: iState;\n  \n\n  /**\n   * Reset the parser\n   * \n   * @private\n   * @memberof HtmlParser\n   */\n  private reset() {\n    this.state = {\n      mode: MODE_TYPES.TEXT,\n      html: '',\n      currentPos: 0,\n      output: []\n    };\n  }\n\n\n  /**\n   * Add a html node element to our output object\n   * \n   * @private\n   * @param {iHtmlElement} newNode \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private addNodeElement(newNode: iHtmlElement, currentElement: iHtmlElement) {\n    if(currentElement) {\n      if(!currentElement.children) { currentElement.children = []; }\n      currentElement.children.push(newNode);\n    } else {\n      this.state.output.push(newNode);\n    }\n  }\n\n\n  /**\n   * Create a text node\n   * \n   * @private\n   * @param {string} text \n   * @returns {iHtmlElement} \n   * @memberof HtmlParser\n   */\n  private createTextNode(text: string): iHtmlElement {\n    return {\n      type: ELEMENT_TYPES.TEXT,\n      data: text\n    };\n  }\n\n\n  /**\n   * Create a comment node\n   * \n   * @private\n   * @param {string} comment \n   * @returns {iHtmlElement} \n   * @memberof HtmlParser\n   */\n  private createCommentNode(comment: string): iHtmlElement {\n    return {\n      type: ELEMENT_TYPES.COMMENT,\n      data: comment\n    };\n  }\n\n\n  /**\n   * Create a tag node\n   * \n   * @private\n   * @param {string} tag \n   * @returns {iHtmlElement} \n   * @memberof HtmlParser\n   */\n  private createTagNode(tag: string): iHtmlElement {\n    let posOfFirstSpace = tag.indexOf(\" \");\n    let posOfGreaterThan = tag.indexOf(\">\");\n    let endIndex = (posOfFirstSpace > -1 && posOfFirstSpace < posOfGreaterThan)\n      ? posOfFirstSpace : posOfGreaterThan;\n    let name = tag.substring(1, endIndex);\n    return {\n      type: ELEMENT_TYPES.TAG,\n      tagType: this.getTagType(name),\n      name: name,\n      attributes: this.parseAttributes(tag),\n      children: [] \n    };\n  }\n\n\n  /**\n   * Get the type of tag\n   * \n   * @private\n   * @param {string} name \n   * @returns {string} \n   * @memberof HtmlParser\n   */\n  private getTagType(name: string): string {\n    name = name.toLowerCase();\n    if(EMPTY_TAGS[name]) {\n      return TAG_TYPES.EMPTY;\n    } else if(name === TAG_TYPES.STYLE) {\n      return TAG_TYPES.STYLE;\n    } else if(name === TAG_TYPES.SCRIPT) {\n      return TAG_TYPES.SCRIPT;\n    } else if(name === TAG_TYPES.COMMENT) {\n      return TAG_TYPES.COMMENT;\n    }\n    return TAG_TYPES.DEFAULT;\n  }\n\n\n  /**\n   * Get the next tag from a text string, it could be a start or end tag\n   * \n   * @private\n   * @param {string} text \n   * @returns {iSearchTagResult} \n   * @memberof HtmlParser\n   */\n  private getNextTag(text: string): iSearchTagResult {\n    let pos = 0;\n    while(pos < text.length) {\n      if(utility.isStartOfTag(text[pos], text[pos + 1])) {\n        return {\n          type: 'start',\n          pos: pos \n        };\n      } else if(utility.isEndOfTag(text[pos], text[pos + 1])) {\n        return {\n          type: 'end',\n          pos: pos\n        }\n      } else if(utility.isStartOfComment(text.substr(pos))) {\n        return {\n          type: 'comment',\n          pos: pos\n        }\n      }\n      pos++;\n    }\n    return { type: 'no-tag' };\n  }\n\n\n  /**\n   * Parse for text\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private parseText(currentElement: iHtmlElement) {\n    let nextText = this.state.html.substring(this.state.currentPos);\n    let tagResult = this.getNextTag(nextText);\n    if(tagResult.type === 'start') {\n      this.handleStartTagInText(tagResult, nextText, currentElement);\n    } else if(tagResult.type === 'end') {\n      this.handleEndTagInText(tagResult, nextText, currentElement);\n    } else if(tagResult.type === 'comment') {\n      this.handleCommentInText(tagResult, nextText, currentElement);\n    }else {\n      // no tag found\n      if(nextText.length > 0) {\n        let textNode = this.createTextNode(nextText);\n        this.addNodeElement(textNode, currentElement);\n      }\n    }\n  }\n\n\n  /**\n   * Handle finding the start tag of a html element\n   * \n   * @private\n   * @param {iSearchTagResult} tagResult \n   * @param {string} nextText \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private handleStartTagInText(tagResult: iSearchTagResult, \n  nextText: string, currentElement: iHtmlElement): void {\n    if(tagResult.pos > 0) {\n      // there must be text before our html start tag\n      let text = nextText.substring(0, tagResult.pos);\n      let textNode = this.createTextNode(text);\n      this.addNodeElement(textNode, currentElement);\n    }\n    // need to now parse the html tag\n    this.state.mode = MODE_TYPES.TAG;\n    this.state.currentPos = this.state.currentPos + tagResult.pos;\n    this._parse(currentElement);\n  }\n\n\n  /**\n   * Handing finding the end tag of a html element\n   * \n   * @private\n   * @param {iSearchTagResult} tagResult \n   * @param {string} nextText \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private handleEndTagInText(tagResult: iSearchTagResult, \n  nextText: string, currentElement: iHtmlElement): void {\n    if(tagResult.pos > 0) {\n      // there must be text before our html end tag\n      let text = nextText.substring(0, tagResult.pos);\n      let textNode = this.createTextNode(text);\n      this.addNodeElement(textNode, currentElement);\n    }\n    // validate the end tag is correct\n    let posEndTag = nextText.indexOf('>') + 1;\n    let tagText = nextText.substring(tagResult.pos, posEndTag);\n    let tagName = tagText.replace(\"</\", \"\").replace(\">\", \"\");\n    if(!currentElement) {\n      throw new Error('No start tag for end tag: ' + tagName);\n    }\n    if(currentElement.name.toLowerCase() !== tagName.toLowerCase()) {\n      throw new Error('Start tag (' + currentElement.name + ') and end tag '\n      + '(' + tagName + ') do not match');\n    }\n    this.state.mode = MODE_TYPES.TEXT;\n    this.state.currentPos = this.state.currentPos + posEndTag;\n    let parentElement = currentElement.parentElement;\n    delete currentElement.parentElement;\n    this._parse(parentElement);\n  }\n\n\n  /**\n   * Handle finding a comment in text\n   * \n   * @private\n   * @param {iSearchTagResult} tagResult \n   * @param {string} nextText \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private handleCommentInText(tagResult: iSearchTagResult, \n  nextText: string, currentElement: iHtmlElement) {\n    if(tagResult.pos > 0) {\n      // there must be text before our html end tag\n      let text = nextText.substring(0, tagResult.pos);\n      let textNode = this.createTextNode(text);\n      this.addNodeElement(textNode, currentElement);\n    }\n    let posEndCommentTag = nextText.indexOf('-->');\n    if(!posEndCommentTag) {\n      throw new Error('Comment does not have an end tag');\n    }\n    let commentText = nextText.substring(tagResult.pos + 4, posEndCommentTag);\n    let commentNode = this.createCommentNode(commentText);\n    this.addNodeElement(commentNode, currentElement);\n    this.state.mode = MODE_TYPES.TEXT;\n    this.state.currentPos = this.state.currentPos + (posEndCommentTag + 3);\n    this._parse(currentElement);\n  }\n\n\n  /**\n   * Parse a tag\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private parseTag(currentElement: iHtmlElement) {\n    let nextText = this.state.html.substring(this.state.currentPos);\n    let posEndTag = nextText.indexOf('>') + 1;\n    let tagText = nextText.substring(0, posEndTag);\n    let tagNode = this.createTagNode(tagText);\n    // move to the end of our start tag\n    this.state.currentPos = this.state.currentPos + posEndTag;\n    this.addNodeElement(tagNode, currentElement);\n    this.state.mode = MODE_TYPES.TEXT;\n    if(tagNode.tagType === TAG_TYPES.EMPTY) {\n      // empty tags can not have children\n      this._parse(currentElement);\n    } else if(tagNode.tagType === TAG_TYPES.STYLE) {\n      this.state.mode = MODE_TYPES.STYLE;\n      tagNode.parentElement = currentElement;\n      this._parse(tagNode);\n    } else if(tagNode.tagType === TAG_TYPES.SCRIPT) {\n      this.state.mode = MODE_TYPES.SCRIPT;\n      tagNode.parentElement = currentElement;\n      this._parse(tagNode);\n    } else {\n      tagNode.parentElement = currentElement;\n      this._parse(tagNode);\n    }\n  }\n\n\n  /**\n   * Parse for attributes in a html tag\n   * \n   * @private\n   * @param {string} tag \n   * @returns {{ [key: string]: any }} \n   * @memberof HtmlParser\n   */\n  private parseAttributes(tag: string): { [key: string]: any } {\n    let attrParser = new AttributeParser();\n    return attrParser.parse(tag);\n  }\n\n\n  /**\n   * Parse a script tag like: <script> or <style>\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @param {string} endTag \n   * @memberof HtmlParser\n   */\n  private parseScript(currentElement: iHtmlElement, endTag: string) {\n    let nextText = this.state.html.substring(this.state.currentPos);\n    let posOfEndTag = nextText.indexOf(endTag);\n    if(posOfEndTag < 0) {\n      throw new Error('Script (' + currentElement.name + ' ) does not have ' +\n      'an end tag');\n    }\n    let scriptContent = nextText.substring(0, posOfEndTag);\n    let textNode = this.createTextNode(scriptContent);\n    this.addNodeElement(textNode, currentElement);\n    this.state.currentPos = this.state.currentPos \n      + (posOfEndTag + endTag.length);\n    this.state.mode = MODE_TYPES.TEXT;\n    let parentElement = currentElement.parentElement;\n    delete currentElement.parentElement;\n    this._parse(parentElement);\n  }\n\n\n  /**\n   * Keep parsing the html string\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private _parse(currentElement: iHtmlElement) {\n    switch(this.state.mode) {\n      case MODE_TYPES.TEXT:\n        this.parseText(currentElement);\n        break;\n      case MODE_TYPES.TAG:\n        this.parseTag(currentElement);\n        break;\n      case MODE_TYPES.STYLE:\n        this.parseScript(currentElement, \"</style>\");\n        break;\n      case MODE_TYPES.SCRIPT:\n        this.parseScript(currentElement, \"</script>\");\n        break;\n    }\n  }\n\n\n  /**\n   * Parse a html string\n   * \n   * @param {string} html \n   * @returns {iHtmlElement []} \n   * @memberof HtmlParser\n   */\n  public parse(html: string):iHtmlElement [] {\n    this.reset();\n    this.state.html = html;\n    this._parse(null);\n    return this.state.output;\n  }\n\n\n  /**\n   * Reverse the output from the parse function back to html string\n   * \n   * @param {iHtmlElement[]} htmlNodes \n   * @returns {string} \n   * @memberof HtmlParser\n   */\n  public reverse(htmlNodes: iHtmlElement[]) {\n    return this.reverseNodes(0, htmlNodes, '');\n  }\n\n\n  /**\n   * Reverse an array of html element nodes into a html string\n   * \n   * @private\n   * @param {number} index \n   * @param {iHtmlElement[]} htmlNodes \n   * @param {string} html \n   * @returns \n   * @memberof HtmlParser\n   */\n  private reverseNodes(index: number, htmlNodes: iHtmlElement[], html: string) {\n    if(index >= htmlNodes.length) {\n      return html;\n    }\n    let node = htmlNodes[index];\n    if(node.type === ELEMENT_TYPES.TEXT) {\n      html += node.data;\n    } else if(node.type === ELEMENT_TYPES.COMMENT) {\n      html += '<!--' + node.data + '-->';\n    } else {\n      let attrParser = new AttributeParser();\n      let textAttr = attrParser.reverse(node.attributes);\n      textAttr = (textAttr.length > 0) ? ' ' + textAttr : textAttr;\n      // tag type\n      if(node.tagType === TAG_TYPES.EMPTY) {\n        html += '<' + node.name + textAttr + ' />';\n      } else {\n        html += '<' + node.name + textAttr + '>';\n        if(node.children && node.children.length > 0) {\n          let newHtml = this.reverseNodes(0, node.children, '');\n          html += newHtml;\n        }\n        html += '</' + node.name + '>';\n      }\n    }\n    index++;\n    return this.reverseNodes(index, htmlNodes, html);\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/html-parser.ts","/**\n * Utility class\n * \n * @export\n * @class Utility\n */\nexport class Utility {\n\n  \n\n\n  /**\n   * Determine if a character is a letter\n   * \n   * @param {string} ch \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isLetter(ch: string): boolean {\n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n  }\n\n  /**\n   * Determine if the two characters are the start a html tag. HTML tags\n   * must start like <a <b \n   * \n   * @param {string} ch \n   * @param {string} nextCh \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isStartOfTag(ch: string, nextCh: string): boolean {\n    if(!ch || !nextCh) { return false; }\n    return (ch === \"<\" && this.isLetter(nextCh));\n  }\n\n\n  /**\n   * Determine if the two characters are the end of a html tag./\n   * \n   * @param {string} ch \n   * @param {string} nextCh \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isEndOfTag(ch: string, nextCh: string): boolean {\n    if(!ch || !nextCh) { return false; }\n    return (ch === \"<\" && nextCh === \"/\");\n  }\n\n\n  /**\n   * Determine if its the start of a html comment\n   * \n   * @param {string} text \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isStartOfComment(text: string): boolean {\n    return (text.indexOf('<!--') === 0);\n  }\n}\n\n// export as singleton\nlet utility = new Utility();\nexport { utility };\n\n\n// WEBPACK FOOTER //\n// ./src/utility.ts"],"sourceRoot":""}