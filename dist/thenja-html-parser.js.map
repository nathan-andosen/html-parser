{"version":3,"sources":["webpack://Thenja/webpack/universalModuleDefinition","webpack://Thenja/webpack/bootstrap","webpack://Thenja/./src/constants.ts","webpack://Thenja/./src/utility.ts","webpack://Thenja/./src/index.ts","webpack://Thenja/./src/html-parser.ts","webpack://Thenja/./src/attribute-parser.ts","webpack://Thenja/./src/clean-parser.ts"],"names":[],"mappings":"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","file":"thenja-html-parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Thenja\"] = factory();\n\telse\n\t\troot[\"Thenja\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","export const ELEMENT_TYPES = {\n  TAG: \"tag\",\n  TEXT: \"text\",\n  COMMENT: \"comment\"\n};\n\nexport const EMPTY_TAGS = {\n  \"area\": 1,\n  \"base\": 1,\n  \"basefont\": 1,\n  \"br\": 1,\n  \"col\": 1,\n  \"frame\": 1,\n  \"hr\": 1,\n  \"img\": 1,\n  \"input\": 1,\n  \"isindex\": 1,\n  \"link\": 1,\n  \"meta\": 1,\n  \"param\": 1,\n  \"embed\": 1\n};\n\nexport const MODE_TYPES = {\n  TEXT: 'text',\n  TAG: 'tag',\n  STYLE: 'style',\n  SCRIPT: 'script'\n};\n\nexport const TAG_TYPES = {\n  EMPTY: 'empty',\n  DEFAULT: 'default',\n  SCRIPT: 'script',\n  STYLE: 'style',\n  COMMENT: 'comment'\n};\n\nexport const QUOTE_TYPES = {\n  SINGLE: 1,\n  DOUBLE: 2\n};","/**\n * Utility class\n * \n * @export\n * @class Utility\n */\nexport class Utility {\n\n  /**\n   * Remove all white space from text\n   * \n   * @param {string} text \n   * @returns \n   * @memberof Utility\n   */\n  public removeWhitespace(text: string) {\n    var tab = '\\u0009';\n    var noBreakSpace = '\\u00A0';\n    var newLine = '\\n';\n    var CR = '\\u000D';\n    var LF = '\\u000A';\n\n    text = text.trim();\n    text = text.split(' ').join(\"\");\n    text = text.split(tab).join(\"\");\n    text = text.split(noBreakSpace).join(\"\");\n    text = text.split(newLine).join(\"\");\n    text = text.split(CR).join(\"\");\n    text = text.split(LF).join(\"\");\n    return text;\n  }\n\n\n  /**\n   * Check if a character is whitespace\n   * \n   * @param {string} ch \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isWhitespace(ch: string): boolean {\n    var tab = '\\u0009';\n    var noBreakSpace = '\\u00A0';\n    var newLine = '\\n';\n    var CR = '\\u000D';\n    var LF = '\\u000A';\n    return (ch === tab) || (ch === ' ') || (ch === noBreakSpace) \n      || (ch === newLine) || (ch === CR) || (ch === LF);\n  }\n\n\n  /**\n   * Determine if a string of text contains only whitespace characters\n   * \n   * @param {string} text \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public textOnlyContainsWhitespace(text: string) : boolean {\n    let isOnlyWhitespace = true;\n    if(!text) { return isOnlyWhitespace; }\n    for(let i = 0; i < text.length; i++) {\n      if(!this.isWhitespace(text[i])) {\n        isOnlyWhitespace = false;\n        break;\n      }\n    }\n    return isOnlyWhitespace;\n  }\n\n\n  /**\n   * Determine if a character is a letter\n   * \n   * @param {string} ch \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isLetter(ch: string): boolean {\n    return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n  }\n\n  /**\n   * Determine if the two characters are the start a html tag. HTML tags\n   * must start like <a <b \n   * \n   * @param {string} ch \n   * @param {string} nextCh \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isStartOfTag(ch: string, nextCh: string): boolean {\n    if(!ch || !nextCh) { return false; }\n    return (ch === \"<\" && this.isLetter(nextCh));\n  }\n\n\n  /**\n   * Determine if the two characters are the end of a html tag./\n   * \n   * @param {string} ch \n   * @param {string} nextCh \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isEndOfTag(ch: string, nextCh: string): boolean {\n    if(!ch || !nextCh) { return false; }\n    return (ch === \"<\" && nextCh === \"/\");\n  }\n\n\n  /**\n   * Determine if its the start of a html comment\n   * \n   * @param {string} text \n   * @returns {boolean} \n   * @memberof Utility\n   */\n  public isStartOfComment(text: string): boolean {\n    return (text.indexOf('<!--') === 0);\n  }\n}\n\n// export as singleton\nlet utility = new Utility();\nexport { utility };","export { ELEMENT_TYPES, TAG_TYPES } from './constants';\nexport { iHtmlElement, iCleanOptions } from './interfaces';\nexport { HtmlParser } from './html-parser';","import { utility } from './utility';\nimport {\n  ELEMENT_TYPES,\n  EMPTY_TAGS,\n  MODE_TYPES,\n  TAG_TYPES,\n  QUOTE_TYPES\n} from './constants';\nimport { \n  iHtmlElement, \n  iSearchTagResult, \n  iState, \n  iCleanOptions \n} from './interfaces';\nimport { AttributeParser } from './attribute-parser';\nimport { CleanParser } from './clean-parser';\n\n\n/**\n * Parse html string into an array of json objects that represent html elements\n * \n * @export\n * @class HtmlParser\n */\nexport class HtmlParser {\n\n  // the state when parsing\n  private state: iState;\n  private errorCb: (err: Error) => void = null;\n  private addNodeCb: (nodeBeingAdded: iHtmlElement, \n    parentElement: iHtmlElement) => void = null;\n  private stringifyNodeCb: (node: iHtmlElement) => void = null;\n  \n\n  /**\n   * Reset the parser\n   * \n   * @private\n   * @memberof HtmlParser\n   */\n  private reset() {\n    this.state = {\n      mode: MODE_TYPES.TEXT,\n      html: '',\n      currentPos: 0,\n      output: []\n    };\n  }\n\n\n  /**\n   * Add a html node element to our output object\n   * \n   * @private\n   * @param {iHtmlElement} newNode \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private addNodeElement(newNode: iHtmlElement, currentElement: iHtmlElement) {\n    if(this.addNodeCb) {\n      this.addNodeCb(newNode, currentElement);\n    }\n    if(currentElement) {\n      if(!currentElement.children) { currentElement.children = []; }\n      currentElement.children.push(newNode);\n    } else {\n      this.state.output.push(newNode);\n    }\n  }\n\n\n  /**\n   * Create a text node\n   * \n   * @private\n   * @param {string} text \n   * @returns {iHtmlElement} \n   * @memberof HtmlParser\n   */\n  private createTextNode(text: string): iHtmlElement {\n    return {\n      type: ELEMENT_TYPES.TEXT,\n      data: text\n    };\n  }\n\n\n  /**\n   * Create a comment node\n   * \n   * @private\n   * @param {string} comment \n   * @returns {iHtmlElement} \n   * @memberof HtmlParser\n   */\n  private createCommentNode(comment: string): iHtmlElement {\n    return {\n      type: ELEMENT_TYPES.COMMENT,\n      data: comment\n    };\n  }\n\n\n  /**\n   * Create a tag node\n   * \n   * @private\n   * @param {string} tag \n   * @returns {iHtmlElement} \n   * @memberof HtmlParser\n   */\n  private createTagNode(tag: string): iHtmlElement {\n    let posOfFirstSpace = tag.indexOf(\" \");\n    let posOfGreaterThan = tag.indexOf(\">\");\n    let endIndex = (posOfFirstSpace > -1 && posOfFirstSpace < posOfGreaterThan)\n      ? posOfFirstSpace : posOfGreaterThan;\n    let name = tag.substring(1, endIndex);\n    name = utility.removeWhitespace(name);\n    return {\n      type: ELEMENT_TYPES.TAG,\n      tagType: this.getTagType(name),\n      name: name,\n      attributes: this.parseAttributes(tag),\n      children: [] \n    };\n  }\n\n\n  /**\n   * Get the type of tag\n   * \n   * @private\n   * @param {string} name \n   * @returns {string} \n   * @memberof HtmlParser\n   */\n  private getTagType(name: string): string {\n    name = name.toLowerCase();\n    if(EMPTY_TAGS[name]) {\n      return TAG_TYPES.EMPTY;\n    } else if(name === TAG_TYPES.STYLE) {\n      return TAG_TYPES.STYLE;\n    } else if(name === TAG_TYPES.SCRIPT) {\n      return TAG_TYPES.SCRIPT;\n    } else if(name === TAG_TYPES.COMMENT) {\n      return TAG_TYPES.COMMENT;\n    }\n    return TAG_TYPES.DEFAULT;\n  }\n\n\n  /**\n   * Get the next tag from a text string, it could be a start or end tag\n   * \n   * @private\n   * @param {string} text \n   * @returns {iSearchTagResult} \n   * @memberof HtmlParser\n   */\n  private getNextTag(text: string): iSearchTagResult {\n    let pos = 0;\n    while(pos < text.length) {\n      if(utility.isStartOfTag(text[pos], text[pos + 1])) {\n        return {\n          type: 'start',\n          pos: pos \n        };\n      } else if(utility.isEndOfTag(text[pos], text[pos + 1])) {\n        return {\n          type: 'end',\n          pos: pos\n        }\n      } else if(utility.isStartOfComment(text.substr(pos))) {\n        return {\n          type: 'comment',\n          pos: pos\n        }\n      }\n      pos++;\n    }\n    return { type: 'no-tag' };\n  }\n\n\n  /**\n   * Parse for text\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private parseText(currentElement: iHtmlElement) {\n    let nextText = this.state.html.substring(this.state.currentPos);\n    let tagResult = this.getNextTag(nextText);\n    if(tagResult.type === 'start') {\n      this.handleStartTagInText(tagResult, nextText, currentElement);\n    } else if(tagResult.type === 'end') {\n      this.handleEndTagInText(tagResult, nextText, currentElement);\n    } else if(tagResult.type === 'comment') {\n      this.handleCommentInText(tagResult, nextText, currentElement);\n    }else {\n      // no tag found\n      if(nextText.length > 0) {\n        let textNode = this.createTextNode(nextText);\n        this.addNodeElement(textNode, currentElement);\n      }\n    }\n  }\n\n\n  /**\n   * Handle finding the start tag of a html element\n   * \n   * @private\n   * @param {iSearchTagResult} tagResult \n   * @param {string} nextText \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private handleStartTagInText(tagResult: iSearchTagResult, \n  nextText: string, currentElement: iHtmlElement): void {\n    if(tagResult.pos > 0) {\n      // there must be text before our html start tag\n      let text = nextText.substring(0, tagResult.pos);\n      let textNode = this.createTextNode(text);\n      this.addNodeElement(textNode, currentElement);\n    }\n    // need to now parse the html tag\n    this.state.mode = MODE_TYPES.TAG;\n    this.state.currentPos = this.state.currentPos + tagResult.pos;\n    this._parse(currentElement);\n  }\n\n\n  /**\n   * Handing finding the end tag of a html element\n   * \n   * @private\n   * @param {iSearchTagResult} tagResult \n   * @param {string} nextText \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private handleEndTagInText(tagResult: iSearchTagResult, \n  nextText: string, currentElement: iHtmlElement): void {\n    if(tagResult.pos > 0) {\n      // there must be text before our html end tag\n      let text = nextText.substring(0, tagResult.pos);\n      let textNode = this.createTextNode(text);\n      this.addNodeElement(textNode, currentElement);\n    }\n    // validate the end tag is correct\n    let posEndTag = nextText.indexOf('>', tagResult.pos) + 1;\n    let tagText = nextText.substring(tagResult.pos, posEndTag);\n    let tagName = tagText.replace(\"</\", \"\").replace(\">\", \"\");\n    if(!currentElement) {\n      let err = new Error('No start tag for end tag: ' + tagName);\n      if(this.errorCb) { this.errorCb(err); }\n    }\n    if(currentElement.name.toLowerCase() !== tagName.toLowerCase()) {\n      let err = Error('Start tag (' + currentElement.name + ') and end tag '\n      + '(' + tagName + ') do not match');\n      if(this.errorCb) { this.errorCb(err); }\n    }\n    this.state.mode = MODE_TYPES.TEXT;\n    this.state.currentPos = this.state.currentPos + posEndTag;\n    let parentElement = currentElement.parentElement;\n    delete currentElement.parentElement;\n    this._parse(parentElement);\n  }\n\n\n  /**\n   * Handle finding a comment in text\n   * \n   * @private\n   * @param {iSearchTagResult} tagResult \n   * @param {string} nextText \n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private handleCommentInText(tagResult: iSearchTagResult, \n  nextText: string, currentElement: iHtmlElement) {\n    if(tagResult.pos > 0) {\n      // there must be text before our html end tag\n      let text = nextText.substring(0, tagResult.pos);\n      let textNode = this.createTextNode(text);\n      this.addNodeElement(textNode, currentElement);\n    }\n    let posEndCommentTag = nextText.indexOf('-->');\n    if(!posEndCommentTag) {\n      let err = new Error('Comment does not have an end tag');\n      if(this.errorCb) { this.errorCb(err); }\n    }\n    let commentText = nextText.substring(tagResult.pos + 4, posEndCommentTag);\n    let commentNode = this.createCommentNode(commentText);\n    this.addNodeElement(commentNode, currentElement);\n    this.state.mode = MODE_TYPES.TEXT;\n    this.state.currentPos = this.state.currentPos + (posEndCommentTag + 3);\n    this._parse(currentElement);\n  }\n\n\n  /**\n   * Parse a tag\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private parseTag(currentElement: iHtmlElement) {\n    let nextText = this.state.html.substring(this.state.currentPos);\n    let posEndTag = this.findPositionOfClosingTag(nextText) + 1;\n    let tagText = nextText.substring(0, posEndTag);\n    let tagNode = this.createTagNode(tagText);\n    // move to the end of our start tag\n    this.state.currentPos = this.state.currentPos + posEndTag;\n    this.addNodeElement(tagNode, currentElement);\n    this.state.mode = MODE_TYPES.TEXT;\n    if(tagNode.tagType === TAG_TYPES.EMPTY) {\n      // empty tags can not have children\n      this._parse(currentElement);\n    } else if(tagNode.tagType === TAG_TYPES.STYLE) {\n      this.state.mode = MODE_TYPES.STYLE;\n      tagNode.parentElement = currentElement;\n      this._parse(tagNode);\n    } else if(tagNode.tagType === TAG_TYPES.SCRIPT) {\n      this.state.mode = MODE_TYPES.SCRIPT;\n      tagNode.parentElement = currentElement;\n      this._parse(tagNode);\n    } else {\n      tagNode.parentElement = currentElement;\n      this._parse(tagNode);\n    }\n  }\n\n\n  /**\n   * Find the position of the greater than symbol for a html tag element. \n   * \n   * @private\n   * @param {string} text \n   * @returns \n   * @memberof HtmlParser\n   */\n  private findPositionOfClosingTag(text: string) {\n    let posOfFirstSpace = text.indexOf(\" \");\n    let pos = (posOfFirstSpace > -1) ? posOfFirstSpace + 1 : 0;\n    let posOfGreaterThan = text.indexOf(\">\");\n    if(posOfGreaterThan < pos) {\n      return posOfGreaterThan;\n    }\n    let quoteType = null;\n    let insideQuote = false;\n    while(true) {\n      let ch = (pos < text.length) ? text[pos] : null;\n      if(ch === '>' && !insideQuote) {\n        return pos;\n      } else if(ch === \"'\") {\n        if(insideQuote && quoteType === QUOTE_TYPES.SINGLE) {\n          insideQuote = false;\n        } else if(!insideQuote) {\n          insideQuote = true;\n          quoteType = QUOTE_TYPES.SINGLE;\n        }\n      } else if(ch === '\"') {\n        if(insideQuote && quoteType === QUOTE_TYPES.DOUBLE) {\n          insideQuote = false;\n        } else if(!insideQuote) {\n          insideQuote = true;\n          quoteType = QUOTE_TYPES.DOUBLE;\n        }\n      } else if(ch === null) {\n        // if we get here, the html must be really bad\n        break;\n      }\n      pos++;\n    }\n    return text.length - 1;\n  }\n\n\n  /**\n   * Parse for attributes in a html tag\n   * \n   * @private\n   * @param {string} tag \n   * @returns {{ [key: string]: any }} \n   * @memberof HtmlParser\n   */\n  private parseAttributes(tag: string): { [key: string]: any } {\n    let attrParser = new AttributeParser();\n    return attrParser.parse(tag);\n  }\n\n\n  /**\n   * Parse a script tag like: <script> or <style>\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @param {string} endTag \n   * @memberof HtmlParser\n   */\n  private parseScript(currentElement: iHtmlElement, endTag: string) {\n    let nextText = this.state.html.substring(this.state.currentPos);\n    let posOfEndTag = nextText.indexOf(endTag);\n    if(posOfEndTag < 0) {\n      let err = new Error('Script (' + currentElement.name + ' ) does not have ' +\n      'an end tag');\n      if(this.errorCb) { this.errorCb(err); }\n    }\n    let scriptContent = nextText.substring(0, posOfEndTag);\n    let textNode = this.createTextNode(scriptContent);\n    this.addNodeElement(textNode, currentElement);\n    this.state.currentPos = this.state.currentPos \n      + (posOfEndTag + endTag.length);\n    this.state.mode = MODE_TYPES.TEXT;\n    let parentElement = currentElement.parentElement;\n    delete currentElement.parentElement;\n    this._parse(parentElement);\n  }\n\n\n  /**\n   * Keep parsing the html string\n   * \n   * @private\n   * @param {iHtmlElement} currentElement \n   * @memberof HtmlParser\n   */\n  private _parse(currentElement: iHtmlElement) {\n    switch(this.state.mode) {\n      case MODE_TYPES.TEXT:\n        this.parseText(currentElement);\n        break;\n      case MODE_TYPES.TAG:\n        this.parseTag(currentElement);\n        break;\n      case MODE_TYPES.STYLE:\n        this.parseScript(currentElement, \"</style>\");\n        break;\n      case MODE_TYPES.SCRIPT:\n        this.parseScript(currentElement, \"</script>\");\n        break;\n    }\n  }\n\n\n  /**\n   * Parse a html string\n   * \n   * @param {string} html \n   * @param {Function} cb\n   * @returns {iHtmlElement []} \n   * @memberof HtmlParser\n   */\n  public parse(html: string, errorCb?: (err: Error) => void,\n  addNodeCb?: (nodeBeingAdded: iHtmlElement, parentElement: iHtmlElement) => void)\n  : iHtmlElement [] {\n    this.errorCb = (errorCb) ? errorCb : null;\n    this.addNodeCb = (addNodeCb) ? addNodeCb : null;\n    this.reset();\n    this.state.html = html;\n    this._parse(null);\n    return this.state.output;\n  }\n\n\n  /**\n   * Reverse the output from the parse function back to html string\n   * \n   * @param {iHtmlElement[]} htmlNodes \n   * @returns {string} \n   * @memberof HtmlParser\n   */\n  public reverse(htmlNodes: iHtmlElement[], \n  stringifyNodeCb?: (node: iHtmlElement) => void): string {\n    this.stringifyNodeCb = (stringifyNodeCb) ? stringifyNodeCb : null;\n    return this.reverseNodes(0, htmlNodes, '');\n  }\n\n\n  /**\n   * Reverse an array of html element nodes into a html string\n   * \n   * @private\n   * @param {number} index \n   * @param {iHtmlElement[]} htmlNodes \n   * @param {string} html \n   * @returns \n   * @memberof HtmlParser\n   */\n  private reverseNodes(index: number, htmlNodes: iHtmlElement[], html: string) {\n    if(index >= htmlNodes.length) {\n      return html;\n    }\n    let node = htmlNodes[index];\n    if(this.stringifyNodeCb) { this.stringifyNodeCb(node); }\n    if(node.type === ELEMENT_TYPES.TEXT) {\n      html += node.data;\n    } else if(node.type === ELEMENT_TYPES.COMMENT) {\n      html += '<!--' + node.data + '-->';\n    } else {\n      let attrParser = new AttributeParser();\n      let textAttr = attrParser.reverse(node.attributes);\n      textAttr = (textAttr.length > 0) ? ' ' + textAttr : textAttr;\n      // tag type\n      if(node.tagType === TAG_TYPES.EMPTY) {\n        html += '<' + node.name + textAttr + ' />';\n      } else {\n        html += '<' + node.name + textAttr + '>';\n        if(node.children && node.children.length > 0) {\n          let newHtml = this.reverseNodes(0, node.children, '');\n          html += newHtml;\n        }\n        html += '</' + node.name + '>';\n      }\n    }\n    index++;\n    return this.reverseNodes(index, htmlNodes, html);\n  }\n\n\n  /**\n   * Parse html element nodes to clean and remove unwanted tags\n   * \n   * @param {iHtmlElement[]} nodes \n   * @param {iCleanOptions} options \n   * @returns {iHtmlElement[]} \n   * @memberof HtmlParser\n   */\n  public clean(nodes: iHtmlElement[], options?: iCleanOptions): iHtmlElement[] {\n    let cleanParser = new CleanParser();\n    return cleanParser.parse(nodes, options);\n  }\n}","import { utility } from './utility';\n\nconst PARSER_MODES = {\n  READING_ATTR_NAME: 'reading-attr-name',\n  READING_ATTR_VALUE: 'reading-attr-value'\n};\n\n/**\n * Parse attributes in a html tag\n * \n * @export\n * @class AttributeParser\n */\nexport class AttributeParser {\n  \n  // the state when parsing\n  private state: any = {\n    text: '',\n    currentPos: 0,\n    mode: PARSER_MODES.READING_ATTR_NAME,\n    attrName: '',\n    attrValue: ''\n  };\n\n\n  /**\n   * Reset the parser\n   * \n   * @private\n   * @memberof AttributeParser\n   */\n  private reset() {\n    this.state = {\n      text: '',\n      currentPos: 0,\n      mode: 'reading-attr-name',\n      attrName: '',\n      attrValue: ''\n    };\n  }\n\n\n  /**\n   * Get the next character in the text string\n   * \n   * @private\n   * @returns {string} \n   * @memberof AttributeParser\n   */\n  private getNextChar(): string {\n    let ch = null;\n    if(this.state.currentPos < this.state.text.length) {\n      ch = this.state.text.charAt(this.state.currentPos);\n      this.state.currentPos++;\n    }\n    return ch;\n  }\n\n\n  /**\n   * Parse the text of attributes\n   * \n   * @private\n   * @param {string} text \n   * @returns {{ [key: string]: any }} \n   * @memberof AttributeParser\n   */\n  private _parse(text: string): { [key: string]: any } {\n    let attr = {};\n    this.state.text = text;\n    while(true) {\n      let ch = this.getNextChar();\n      if(ch === null) { \n        if(this.state.attrName) {\n          attr[this.state.attrName] = (this.state.attrValue)\n            ? this.state.attrValue : null;\n        }\n        break; \n      }\n      if(this.state.mode === PARSER_MODES.READING_ATTR_NAME) {\n        this.handleReadingAttrName(ch, attr);\n      } else if(this.state.mode === PARSER_MODES.READING_ATTR_VALUE) {\n        this.handleReadingAttrValue(ch, attr);\n      }\n    }\n    return attr;\n  }\n\n\n  /**\n   * Handle getting the next character when reading the attribute name\n   * \n   * @private\n   * @param {string} ch \n   * @param {any} attr \n   * @memberof AttributeParser\n   */\n  private handleReadingAttrName(ch: string, attr) {\n    if(ch === '=') {\n      // end of the attribute name\n      this.state.mode = PARSER_MODES.READING_ATTR_VALUE;\n    } else if(ch === '/') {\n      // not an attribute, probably just an end tag, like <input />\n      // do nothing\n    } else if(utility.isWhitespace(ch)) {\n      // possibily be an attribute without a value\n      if(this.state.attrName) {\n        attr[this.state.attrName] = null;\n        this.state.attrName = '';\n      }\n    } else {\n      this.state.attrName = this.state.attrName + ch;\n    }\n  }\n\n\n  /**\n   * Handle getting the next character when reading the attribute value\n   * \n   * @private\n   * @param {string} ch \n   * @param {any} attr \n   * @memberof AttributeParser\n   */\n  private handleReadingAttrValue(ch: string, attr) {\n    if(utility.isWhitespace(ch)) {\n      let firstCh = this.state.attrValue[0];\n      let lastCh = this.state.attrValue[this.state.attrValue.length - 1];\n      if((firstCh === \"'\" || firstCh === '\"') && firstCh !== lastCh) {\n        // we must be dealing with a whitespace in a string, something like\n        // class=\"one two\"\n        this.state.attrValue = this.state.attrValue + ch;\n      } else {\n        attr[this.state.attrName] = this.state.attrValue;\n        this.state.mode = PARSER_MODES.READING_ATTR_NAME;\n        this.state.attrName = '';\n        this.state.attrValue = '';\n      }\n    } else {\n      this.state.attrValue = this.state.attrValue + ch;\n    }\n  }\n\n\n  /**\n   * Parse a html tag for attributes\n   * \n   * @param {string} tag \n   * @returns \n   * @memberof AttributeParser\n   */\n  public parse(tag: string) {\n    this.reset();\n    let attr = {};\n    let posOfFirstSpace = tag.indexOf(\" \");\n    let posOfGreaterThan = tag.lastIndexOf(\">\");\n    if(posOfFirstSpace > -1 && posOfFirstSpace < posOfGreaterThan) {\n      // we possibiliy have attributes\n      let text = tag.substring(posOfFirstSpace, posOfGreaterThan);\n      text = text.trim();\n      attr = this._parse(text);\n    }\n    return attr;\n  }\n\n\n  /**\n   * Reverse the output of the parse function back to a string of attributes\n   * \n   * @param {{ [key: string]: any}} attributes \n   * @returns {string} \n   * @memberof AttributeParser\n   */\n  public reverse(attributes: { [key: string]: any}): string {\n    let textAttr = '';\n    for(let key in attributes) {\n      if(attributes[key] === null) {\n        textAttr += ' ' + key;\n      } else {\n        textAttr += ' ' + key + '=' + attributes[key];\n      }\n    }\n    return textAttr.trim();\n  }\n}","import { iHtmlElement, iCleanOptions } from './interfaces';\nimport { ELEMENT_TYPES, TAG_TYPES } from './constants';\nimport { utility } from './utility';\n\n/**\n * Clean up the array of node elements returned from the HtmlParser.parse()\n * function\n * \n * @export\n * @class CleanParser\n */\nexport class CleanParser {\n  private removeEmptyTags;\n  private removeEmptyTextNodes;\n\n\n  /**\n   * Set the options for the parser\n   * \n   * @private\n   * @param {iCleanOptions} options \n   * @memberof CleanParser\n   */\n  private setOptions(options: iCleanOptions) {\n    options = options || {};\n    this.removeEmptyTags = (typeof options.removeEmptyTags !== 'undefined')\n      ? options.removeEmptyTags : true;\n    this.removeEmptyTextNodes = \n      (typeof options.removeEmptyTextNodes !== 'undefined')\n      ? options.removeEmptyTextNodes : true;\n  }\n\n\n  /**\n   * Remove text nodes that only contain whitespace\n   * \n   * @private\n   * @param {number} index \n   * @param {iHtmlElement[]} nodes \n   * @returns {void} \n   * @memberof CleanParser\n   */\n  private parseAndRemoveEmptyText(index: number, nodes: iHtmlElement[]): void {\n    if(index >= nodes.length) {\n      return;\n    }\n    let node = nodes[index];\n    if(node.type === ELEMENT_TYPES.TEXT \n    && utility.textOnlyContainsWhitespace(node.data)) {\n      nodes.splice(index, 1);\n      index--;\n    } else if(node.type === ELEMENT_TYPES.TAG && node.children\n    && node.children.length > 0) {\n      this.parseAndRemoveEmptyText(0, node.children);\n    }\n    this.parseAndRemoveEmptyText(++index, nodes);\n  }\n\n\n  /**\n   * Remove tag elements that are empty\n   * \n   * @private\n   * @param {number} index \n   * @param {iHtmlElement[]} nodes \n   * @returns {void} \n   * @memberof CleanParser\n   */\n  private parseAndRemoveEmptyTags(index: number, nodes: iHtmlElement[]): void {\n    if(index >= nodes.length) {\n      return;\n    }\n    let node = nodes[index];\n    if(node.type === ELEMENT_TYPES.TAG) {\n      if(node.children && node.children.length > 0) {\n        this.parseAndRemoveEmptyTags(0, node.children);\n      } \n      let noChildern = (!node.children || node.children.length <= 0);\n      if(node.tagType === TAG_TYPES.DEFAULT && noChildern) {\n        nodes.splice(index, 1);\n        index--;\n      }\n    }\n    this.parseAndRemoveEmptyTags(++index, nodes);\n  }\n\n\n  /**\n   * Parse html element nodes to clean and remove unwanted tags\n   * \n   * @param {iHtmlElement[]} htmlNodes \n   * @param {iCleanOptions} [options] \n   * @returns {iHtmlElement[]} \n   * @memberof CleanParser\n   */\n  parse(htmlNodes: iHtmlElement[], options?: iCleanOptions): iHtmlElement[] {\n    this.setOptions(options);\n    if(this.removeEmptyTextNodes) {\n      this.parseAndRemoveEmptyText(0, htmlNodes);\n    }\n    if(this.removeEmptyTags) {\n      this.parseAndRemoveEmptyTags(0, htmlNodes);\n    }\n    return htmlNodes;\n  }\n}\n"],"sourceRoot":""}